{
    "docs": [
        {
            "location": "/",
            "text": "What is Lightbus?\n\u00b6\n\n\nLightbus is a powerful but intuitive messaging client for your\nbackend services. Lightbus is for use with Python, but can\ncommunicate with services written in other languages.\n\n\nLightbus uses Redis 5 as its underlying transport, although support\nfor other platforms may be added in future.\n\n\nLightbus is under active development and is still pre-release.\n\n\nHow Lightbus works\n\u00b6\n\n\nLightbus provides you with two tools:\n\n\n\n\nA \nclient\n with which to fire events,\n  and make remote procedure calls (RPCs) from anywhere within your\n  codebase.\n\n\nA \nstand-alone Lightbus worker process\n in which you can setup\n  event listeners. This process will also respond to RPCs calls.\n\n\n\n\nFor example, you could architect an e-commerce system as follows:\n\n\n\n\nIn this example:\n\n\n\n\nDjango\n serves pages using data from the database\n\n\nDjango\n performs remote procedure calls to resize images. The Lightbus\n  worker in the \nimage resizing service\n performs the image resize and responds.\n\n\nThe \nprice monitoring service\n fires \nprice_monitor.competitor_price_changed\n events\n\n\nThe Lightbus worker in the \nonline shop web service\n listens for\n  \nprice_monitor.competitor_price_changed\n events and updates prices in the\n  database accordingly.\n\n\n\n\nSee the \nanatomy lesson\n for further discussion.\n\n\nDesigned for ease of use\n\u00b6\n\n\nLightbus is designed to be intuitive and familiar,\nand common problems are caught with\nclear and helpful error messages.\n\n\nFor example, a na\u00efve authentication API:\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n    \nuser_registered\n \n=\n \nEvent\n(\nparameters\n=\n(\n'user'\n,\n \n'email'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nuser\n,\n \npassword\n):\n\n        \nreturn\n \n(\n\n            \nuser\n \n==\n \n'admin'\n\n            \nand\n \npassword\n \n==\n \n'secret'\n\n        \n)\n\n\n\n\n\nThis can be called as follows:\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\nis_valid\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\n\n    \nuser\n=\n'admin'\n,\n\n    \npassword\n=\n'secret'\n\n\n)\n\n\n# is_valid is True\n\n\n\n\n\nYou can also listen for events:\n\n\n# bus.py\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Our event handler\n\n\ndef\n \nsend_signup_email\n(\nevent_message\n,\n\n                      \nuser\n,\n \nemail\n):\n\n    \nsend_mail\n(\nemail\n,\n\n        \nsubject\n=\nf\n'Welcome \n{user}\n'\n\n    \n)\n\n\n\n# Setup our listeners on startup\n\n\n@bus\n.\nclient\n.\non_start\n()\n\n\ndef\n \non_start\n():\n\n    \nbus\n.\nauth\n.\nuser_registered\n.\nlisten\n(\n\n        \nsend_signup_email\n,\n\n        \nlistener_name\n=\n\"send_signup_email\"\n\n    \n)\n\n\n\n\n\nWhere to start?\n\u00b6\n\n\nStarting with the \ntutorials\n section\n will give you a\n\npractical introduction\n to Lightbus.\nAlternatively, the \nexplanation\n section\n will give you a\ngrounding in the high level \nconcepts and theory\n.\n\n\nStart with whichever section suits you best. You should\nultimately look through both sections for a complete understanding.\n\n\nIn addition, the \nhow to\n section gives solutions to common \nuse cases, and the \nreference\n section provides detailed \ntechnical information regarding specific features.",
            "title": "Home"
        },
        {
            "location": "/#what-is-lightbus",
            "text": "Lightbus is a powerful but intuitive messaging client for your\nbackend services. Lightbus is for use with Python, but can\ncommunicate with services written in other languages.  Lightbus uses Redis 5 as its underlying transport, although support\nfor other platforms may be added in future.  Lightbus is under active development and is still pre-release.",
            "title": "What is Lightbus?"
        },
        {
            "location": "/#how-lightbus-works",
            "text": "Lightbus provides you with two tools:   A  client  with which to fire events,\n  and make remote procedure calls (RPCs) from anywhere within your\n  codebase.  A  stand-alone Lightbus worker process  in which you can setup\n  event listeners. This process will also respond to RPCs calls.   For example, you could architect an e-commerce system as follows:   In this example:   Django  serves pages using data from the database  Django  performs remote procedure calls to resize images. The Lightbus\n  worker in the  image resizing service  performs the image resize and responds.  The  price monitoring service  fires  price_monitor.competitor_price_changed  events  The Lightbus worker in the  online shop web service  listens for\n   price_monitor.competitor_price_changed  events and updates prices in the\n  database accordingly.   See the  anatomy lesson  for further discussion.",
            "title": "How Lightbus works"
        },
        {
            "location": "/#designed-for-ease-of-use",
            "text": "Lightbus is designed to be intuitive and familiar,\nand common problems are caught with\nclear and helpful error messages.  For example, a na\u00efve authentication API:  class   AuthApi ( Api ): \n     user_registered   =   Event ( parameters = ( 'user' ,   'email' )) \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   user ,   password ): \n         return   ( \n             user   ==   'admin' \n             and   password   ==   'secret' \n         )   This can be called as follows:  import   lightbus  bus   =   lightbus . create ()  is_valid   =   bus . auth . check_password ( \n     user = 'admin' , \n     password = 'secret'  )  # is_valid is True   You can also listen for events:  # bus.py  import   lightbus  bus   =   lightbus . create ()  # Our event handler  def   send_signup_email ( event_message , \n                       user ,   email ): \n     send_mail ( email , \n         subject = f 'Welcome  {user} ' \n     )  # Setup our listeners on startup  @bus . client . on_start ()  def   on_start (): \n     bus . auth . user_registered . listen ( \n         send_signup_email , \n         listener_name = \"send_signup_email\" \n     )",
            "title": "Designed for ease of use"
        },
        {
            "location": "/#where-to-start",
            "text": "Starting with the  tutorials  section  will give you a practical introduction  to Lightbus.\nAlternatively, the  explanation  section  will give you a\ngrounding in the high level  concepts and theory .  Start with whichever section suits you best. You should\nultimately look through both sections for a complete understanding.  In addition, the  how to  section gives solutions to common \nuse cases, and the  reference  section provides detailed \ntechnical information regarding specific features.",
            "title": "Where to start?"
        },
        {
            "location": "/tutorial/",
            "text": "Tutorial overview\n\u00b6\n\n\nThese tutorials will give you \na practical concrete introduction to\nLightbus\n. We will link to concepts as we go, but the aim here\nis to get you up and running quickly.\n\n\nDo you prefer to read the theory first?\nFeel free to start with the \nexplanation\n section and come\nback here later.\n\n\n\n\nWe recommend you approach the tutorials in the following order:\n\n\n\n\nInstallation\n\n\nQuick start\n\n\nWorked example\n\n\n\n\nAfter completing these tutorials you should make sure you\nlook over the \nexplanation\n section.",
            "title": "Overview"
        },
        {
            "location": "/tutorial/#tutorial-overview",
            "text": "These tutorials will give you  a practical concrete introduction to\nLightbus . We will link to concepts as we go, but the aim here\nis to get you up and running quickly.  Do you prefer to read the theory first?\nFeel free to start with the  explanation  section and come\nback here later.   We recommend you approach the tutorials in the following order:   Installation  Quick start  Worked example   After completing these tutorials you should make sure you\nlook over the  explanation  section.",
            "title": "Tutorial overview"
        },
        {
            "location": "/tutorial/installation/",
            "text": "1.1. Preface: Installing Python 3.6 (or above)\n\u00b6\n\n\nLightbus requires Python 3.6 or newer as it relies upon Python's new\n\nasyncio\n and \ntype hinting\n features. This is readily available\nfor all major operating systems.\n\n\nPython 3.6 on macOS\n\u00b6\n\n\nYou can check your current version of Python as follows:\n\n\n$ python3 --version\nPython 3.6.4\n\n\n\n\n\nYou need version 3.6 or above to run Lightbus.\n\n\nIf you are running an older version of Python you can install a newer\nversion via one of the following methods:\n\n\n\n\nInstall Python 3.6 using Homebrew\n \u2013 This is the easiest option, you will\n   install that latest version of Python 3.\n\n\nInstall Python 3.6 using Homebrew + pyenv\n \u2013 This option has some additional\n   steps, but you will have complete control over the Python versions available to you.\n   If you work on multiple Python projects this may be more suitable.\n\n\nInstall Python 3.6 manually\n \u2013 Not recommended\n\n\n\n\nPython 3.6 on Linux\n\u00b6\n\n\nYour Linux distribution may already come with Python 3.6 installed. You can check your\nPython version as follows:\n\n\n$ python3 --version\nPython 3.6.4\n\n\n\n\n\nYou need version 3.6 or above to run Lightbus. Digital Ocean has a\n\nbeginner-suitable guide\n on installing Python 3 which you may find useful.\n\n\nIf you require more granular control of your python versions you may find \npyenv\n more suitable.\n\n\nWindows\n\u00b6\n\n\nLightbus is not currently tested for deployment on Windows, so your millage may vary.\nThe Hitchhiker's Guide to Python covers \ninstalling Python 3 on Windows\n.\n\n\n1.2. Installing Lightbus\n\u00b6\n\n\nInstalling using pip (recommended)\n\u00b6\n\n\nAt time of writing we were yet to have an official release. Please install via git in the mean-time.\n\n\n$ pip3 install lightbus\n\n\n\n\n\nInstalling using git\n\u00b6\n\n\nThis will clone the bleeding-edge version Lightbus and install it ready to use. This is useful\nif you need the latest (albeit unstable) changes, or if you wish to modify the Lightbus source.\n\n\n$ pip install https://github.com/adamcharnock/lightbus.git#egg=lightbus\n\n\n\n\n\n1.3. Installing Redis\n\u00b6\n\n\nYou will need Redis 5.0 or above in order to use Lightbus.\n\n\nYou can install Redis 5.0 on macOS by either:\n\n\n\n\nUsing \nHomebrew\n (\nbrew install redis\n), or\n\n\nUsing docker (\ndocker run --rm -p 6379:6379 -d redis\n) \n\n\n\n\n1.4. Check it works\n\u00b6\n\n\nYou should now have:\n\n\n\n\nPython 3.6 or above installed\n\n\nLightbus installed\n\n\nRedis installed and running\n\n\n\n\nYou check check everything is setup correctly by starting up lightbus:\n\n\n$ lightbus run\n\n\n\n\n\nLightbus should start without errors and wait for messages.\nYou can exit using \nCtrl\n+\nC\n.",
            "title": "1. Installation"
        },
        {
            "location": "/tutorial/installation/#11-preface-installing-python-36-or-above",
            "text": "Lightbus requires Python 3.6 or newer as it relies upon Python's new asyncio  and  type hinting  features. This is readily available\nfor all major operating systems.",
            "title": "1.1. Preface: Installing Python 3.6 (or above)"
        },
        {
            "location": "/tutorial/installation/#python-36-on-macos",
            "text": "You can check your current version of Python as follows:  $ python3 --version\nPython 3.6.4  You need version 3.6 or above to run Lightbus.  If you are running an older version of Python you can install a newer\nversion via one of the following methods:   Install Python 3.6 using Homebrew  \u2013 This is the easiest option, you will\n   install that latest version of Python 3.  Install Python 3.6 using Homebrew + pyenv  \u2013 This option has some additional\n   steps, but you will have complete control over the Python versions available to you.\n   If you work on multiple Python projects this may be more suitable.  Install Python 3.6 manually  \u2013 Not recommended",
            "title": "Python 3.6 on macOS"
        },
        {
            "location": "/tutorial/installation/#python-36-on-linux",
            "text": "Your Linux distribution may already come with Python 3.6 installed. You can check your\nPython version as follows:  $ python3 --version\nPython 3.6.4  You need version 3.6 or above to run Lightbus. Digital Ocean has a beginner-suitable guide  on installing Python 3 which you may find useful.  If you require more granular control of your python versions you may find  pyenv  more suitable.",
            "title": "Python 3.6 on Linux"
        },
        {
            "location": "/tutorial/installation/#windows",
            "text": "Lightbus is not currently tested for deployment on Windows, so your millage may vary.\nThe Hitchhiker's Guide to Python covers  installing Python 3 on Windows .",
            "title": "Windows"
        },
        {
            "location": "/tutorial/installation/#12-installing-lightbus",
            "text": "",
            "title": "1.2. Installing Lightbus"
        },
        {
            "location": "/tutorial/installation/#installing-using-pip-recommended",
            "text": "At time of writing we were yet to have an official release. Please install via git in the mean-time.  $ pip3 install lightbus",
            "title": "Installing using pip (recommended)"
        },
        {
            "location": "/tutorial/installation/#installing-using-git",
            "text": "This will clone the bleeding-edge version Lightbus and install it ready to use. This is useful\nif you need the latest (albeit unstable) changes, or if you wish to modify the Lightbus source.  $ pip install https://github.com/adamcharnock/lightbus.git#egg=lightbus",
            "title": "Installing using git"
        },
        {
            "location": "/tutorial/installation/#13-installing-redis",
            "text": "You will need Redis 5.0 or above in order to use Lightbus.  You can install Redis 5.0 on macOS by either:   Using  Homebrew  ( brew install redis ), or  Using docker ( docker run --rm -p 6379:6379 -d redis )",
            "title": "1.3. Installing Redis"
        },
        {
            "location": "/tutorial/installation/#14-check-it-works",
            "text": "You should now have:   Python 3.6 or above installed  Lightbus installed  Redis installed and running   You check check everything is setup correctly by starting up lightbus:  $ lightbus run  Lightbus should start without errors and wait for messages.\nYou can exit using  Ctrl + C .",
            "title": "1.4. Check it works"
        },
        {
            "location": "/tutorial/quick-start/",
            "text": "2.1 Requirements\n\u00b6\n\n\nBefore continuing, ensure you have completed the following steps detailed in\nthe \ninstallation section\n:\n\n\n\n\nInstalled Python 3.6 or above\n\n\nInstalled Lightbus\n\n\nRunning Redis 5 locally on the default port (6379)\n\n\n\n\nOptionally, you can read some additional \nexplanation\n in the\n\nanatomy lesson\n and \nconcepts\n sections.\n\n\n2.2 Define your API\n\u00b6\n\n\nFirst we will define an API for Lightbus to serve.\nThis will be an authentication API and will live in an \nauthentication service.\n\n\nCreate an \nauth_service\n directory and within there create \nthe following in a \nbus.py\n file:\n\n\n# File: auth_service/bus.py\n\n\nimport\n \nlightbus\n\n\n\n# Create your service's bus client. You can import this elsewere\n\n\n# in your service's codebase in order to access the bus\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\nclass\n \nAuthApi\n(\nlightbus\n.\nApi\n):\n\n    \nuser_registered\n \n=\n \nlightbus\n.\nEvent\n(\nparameters\n=\n(\n'username'\n,\n \n'email'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n,\n \npassword\n):\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n\n# Register this API with Lightbus. Lightbus will respond to \n\n\n# remote procedure calls for registered APIs, as well as allow you \n\n\n# as the developer to fire events on any registered APIs.\n\n\nbus\n.\nclient\n.\nregister_api\n(\nAuthApi\n())\n\n\n\n\n\nYou should now be able to startup Lightbus as follows:\n\n\ncd ./auth_service/\nlightbus run\n\n\n\n\nLightbus will output some logging data which will include a list of\nregistered APIs, including your new \nauth\n API:\n\n\n\n\nCongratulations, you have now created an authentication service \nwhich contains a single API named \nauth\n.\n\n\nLeave Lightbus running and open a new terminal window for the next stage.\n\n\n2.3 Remote procedure calls\n\u00b6\n\n\nWith Lightbus still running in another terminal window, \ncreate a new directory alongside \nauth_service\n \ncalled \nanother_service\n. This will be an example service which will \ninteract with the auth service. \n\n\nYou should now have the following structure:\n\n\n\n\n./auth_service/bus.py\n, created above\n\n\n./another_service/\n, which we will create files within now.\n\n\n\n\nWe always we define a service's \nbus\n client within a \nbus.py\n file.\nTherefore, create \n./another_service/bus.py\n containing the following:\n\n\n# File: ./another_service/bus.py\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n\n\nNow create \n./another_service/check_password.py\n. We will use this \nto experiment with making RPC calls:\n\n\n# File: ./another_service/check_password.py\n\n\n\n# Import our service's bus client\n\n\nfrom\n \n.bus\n \nimport\n \nbus\n\n\n\n# Call the check_password() procedure on our auth API\n\n\nvalid\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\n\n    \nusername\n=\n'admin'\n,\n\n    \npassword\n=\n'secret'\n\n\n)\n\n\n\n# Show the result\n\n\nif\n \nvalid\n:\n\n    \nprint\n(\n'Password valid!'\n)\n\n\nelse\n:\n\n    \nprint\n(\n'Oops, bad username or password'\n)\n\n\n\n\n\nRunning this script should show you the following:\n\n\ncd ./another_service/\npython3 ./check_password.py\nPassword valid!\n\n\n\n\n\nLooking at the other terminal window you have open you should see that\nLightbus has also reported that it is handled a remote procedure call.\n\n\n2.4 Events\n\u00b6\n\n\nEvents allow services to broadcast a message to any other services which\ncare to listen. Your service can fire events on any API which has been registered.\n\n\nWe have already created and registered our \nAuthApi\n in \n./auth_service/bus.py\n \nwhich provides the \nuser_registered\n event.\n\n\nFiring events\n\u00b6\n\n\nLet's write a simple script to manually register users and fire events. Note we can only \nfire events for APIs we have registered. We have registered the \nauth\n API in \nauth_service\n, \nso it is within this service that this new script must reside. We could not put the script \nwithin \nanother_service\n as this service does not include the \nAuthApi\n class and can therefore not \nregister it.\n\n\n# ./auth_service/manually_register_user.py\n\n\n\n# Import the service's bus client from bus.py\n\n\nfrom\n \nbus\n \nimport\n \nbus\n\n\n\nprint\n(\n\"New user creation\"\n)\n\n\nnew_username\n \n=\n \ninput\n(\n\"Enter a username: \"\n)\n.\nstrip\n()\n\n\nnew_email\n \n=\n \ninput\n(\n\"Enter the user's email address: \"\n)\n.\nstrip\n()\n\n\n\n# You would normally store the new user in your database\n\n\n# at this point. We don't show this here for simplicity.\n\n\n\n# Let the bus know a user has been registered by firing the event\n\n\nbus\n.\nauth\n.\nuser_registered\n.\nfire\n(\n\n    \nusername\n=\nnew_username\n,\n\n    \nemail\n=\nnew_email\n\n\n)\n\n\n\nprint\n(\n\"Done\"\n)\n\n\n\n\n\nRun this script using:\n\n\ncd\n ./auth_service/\npython3 manually_register_user.py\n\n\n\n\nYou should be prompted for a new username & email address, at which point an event will be \nfired onto the bus. We will make use of this event in the next section.\n\n\nListening for events\n\u00b6\n\n\nPerhaps \nanother_service\n needs to be notified when a user is created. To achieve this \nwe can setup an event listener by modifying \n./another_service/bus.py\n:\n\n\n# File: ./another_service/bus.py\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\ndef\n \nhandler_new_user\n(\nevent\n,\n \nusername\n,\n \nemail\n):\n\n    \nprint\n(\nf\n\"A new user was created in the authentication service:\"\n)\n\n    \nprint\n(\nf\n\"    Username: \n{username}\n\"\n)\n\n    \nprint\n(\nf\n\"    Email: \n{email}\n\"\n)\n\n\n\n\n@bus\n.\nclient\n.\non_start\n()\n\n\nasync\n \ndef\n \nbus_start\n():\n\n    \nawait\n \nbus\n.\nauth\n.\nuser_registered\n.\nlisten_async\n(\n\n        \nhandler_new_user\n,\n\n        \nlistener_name\n=\n\"print_on_new_registration\"\n\n    \n)\n\n\n\n\n\nListening for events requires your service to sit waiting for something to \nhappen. Sitting around and waiting for something to happen is precisely \nwhat the \nlightbus run\n command is for. \n\n\nTherefore, in \none terminal window\n startup the \nlightbus run\n command for \n\nanother_service\n:\n\n\n# In the first terminal window:\n\n\ncd\n ./another_service/\nlightbus run\n\n\n\n\nYour service is now waiting for events.\n\n\nIn the \nsecond terminal window\n let's cause an event to be fired \nusing the script we wrote in the previous section:\n\n\ncd\n ./auth_service/\npython3 manually_register_user.py\n\n\n\n\nYou should see that the event gets sent by the \nmanually_register_user.py\n script within the \n\nauth_service\n, and received by by the \nlightbus run\n process within the \nanother_service\n.\n\n\n\n\nListener names\n\u00b6\n\n\nYou may have noticed we specified the \nlistener_name\n parameter in the above example, \nand we set it to an arbitrary value of \n\"print_on_new_registration\"\n. This is important, because Lightbus tracks \nwhich listeners have received which events. It is this listener name which is used to \nuniquely identify each listener. You don't need to worry about this often, just follow the rule:\n\n\nEnsure you specify a unique \nlistener_name\n every time you setup a new listener\n.\n\n\nThe listener name should be unique within the service. Two listeners with the same name \nwill only receive a partial set of events each.\n\n\n2.5 Next\n\u00b6\n\n\nThis was a simple example to get you started. The \nworked example\n considers\na more realistic scenario involving multiple services.",
            "title": "2. Quick start"
        },
        {
            "location": "/tutorial/quick-start/#21-requirements",
            "text": "Before continuing, ensure you have completed the following steps detailed in\nthe  installation section :   Installed Python 3.6 or above  Installed Lightbus  Running Redis 5 locally on the default port (6379)   Optionally, you can read some additional  explanation  in the anatomy lesson  and  concepts  sections.",
            "title": "2.1 Requirements"
        },
        {
            "location": "/tutorial/quick-start/#22-define-your-api",
            "text": "First we will define an API for Lightbus to serve.\nThis will be an authentication API and will live in an \nauthentication service.  Create an  auth_service  directory and within there create \nthe following in a  bus.py  file:  # File: auth_service/bus.py  import   lightbus  # Create your service's bus client. You can import this elsewere  # in your service's codebase in order to access the bus  bus   =   lightbus . create ()  class   AuthApi ( lightbus . Api ): \n     user_registered   =   lightbus . Event ( parameters = ( 'username' ,   'email' )) \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   username ,   password ): \n         return   username   ==   'admin'   and   password   ==   'secret'  # Register this API with Lightbus. Lightbus will respond to   # remote procedure calls for registered APIs, as well as allow you   # as the developer to fire events on any registered APIs.  bus . client . register_api ( AuthApi ())   You should now be able to startup Lightbus as follows:  cd ./auth_service/\nlightbus run  Lightbus will output some logging data which will include a list of\nregistered APIs, including your new  auth  API:   Congratulations, you have now created an authentication service \nwhich contains a single API named  auth .  Leave Lightbus running and open a new terminal window for the next stage.",
            "title": "2.2 Define your API"
        },
        {
            "location": "/tutorial/quick-start/#23-remote-procedure-calls",
            "text": "With Lightbus still running in another terminal window, \ncreate a new directory alongside  auth_service  \ncalled  another_service . This will be an example service which will \ninteract with the auth service.   You should now have the following structure:   ./auth_service/bus.py , created above  ./another_service/ , which we will create files within now.   We always we define a service's  bus  client within a  bus.py  file.\nTherefore, create  ./another_service/bus.py  containing the following:  # File: ./another_service/bus.py  import   lightbus  bus   =   lightbus . create ()   Now create  ./another_service/check_password.py . We will use this \nto experiment with making RPC calls:  # File: ./another_service/check_password.py  # Import our service's bus client  from   .bus   import   bus  # Call the check_password() procedure on our auth API  valid   =   bus . auth . check_password ( \n     username = 'admin' , \n     password = 'secret'  )  # Show the result  if   valid : \n     print ( 'Password valid!' )  else : \n     print ( 'Oops, bad username or password' )   Running this script should show you the following:  cd ./another_service/\npython3 ./check_password.py\nPassword valid!  Looking at the other terminal window you have open you should see that\nLightbus has also reported that it is handled a remote procedure call.",
            "title": "2.3 Remote procedure calls"
        },
        {
            "location": "/tutorial/quick-start/#24-events",
            "text": "Events allow services to broadcast a message to any other services which\ncare to listen. Your service can fire events on any API which has been registered.  We have already created and registered our  AuthApi  in  ./auth_service/bus.py  \nwhich provides the  user_registered  event.",
            "title": "2.4 Events"
        },
        {
            "location": "/tutorial/quick-start/#firing-events",
            "text": "Let's write a simple script to manually register users and fire events. Note we can only \nfire events for APIs we have registered. We have registered the  auth  API in  auth_service , \nso it is within this service that this new script must reside. We could not put the script \nwithin  another_service  as this service does not include the  AuthApi  class and can therefore not \nregister it.  # ./auth_service/manually_register_user.py  # Import the service's bus client from bus.py  from   bus   import   bus  print ( \"New user creation\" )  new_username   =   input ( \"Enter a username: \" ) . strip ()  new_email   =   input ( \"Enter the user's email address: \" ) . strip ()  # You would normally store the new user in your database  # at this point. We don't show this here for simplicity.  # Let the bus know a user has been registered by firing the event  bus . auth . user_registered . fire ( \n     username = new_username , \n     email = new_email  )  print ( \"Done\" )   Run this script using:  cd  ./auth_service/\npython3 manually_register_user.py  You should be prompted for a new username & email address, at which point an event will be \nfired onto the bus. We will make use of this event in the next section.",
            "title": "Firing events"
        },
        {
            "location": "/tutorial/quick-start/#listening-for-events",
            "text": "Perhaps  another_service  needs to be notified when a user is created. To achieve this \nwe can setup an event listener by modifying  ./another_service/bus.py :  # File: ./another_service/bus.py  import   lightbus  bus   =   lightbus . create ()  def   handler_new_user ( event ,   username ,   email ): \n     print ( f \"A new user was created in the authentication service:\" ) \n     print ( f \"    Username:  {username} \" ) \n     print ( f \"    Email:  {email} \" )  @bus . client . on_start ()  async   def   bus_start (): \n     await   bus . auth . user_registered . listen_async ( \n         handler_new_user , \n         listener_name = \"print_on_new_registration\" \n     )   Listening for events requires your service to sit waiting for something to \nhappen. Sitting around and waiting for something to happen is precisely \nwhat the  lightbus run  command is for.   Therefore, in  one terminal window  startup the  lightbus run  command for  another_service :  # In the first terminal window:  cd  ./another_service/\nlightbus run  Your service is now waiting for events.  In the  second terminal window  let's cause an event to be fired \nusing the script we wrote in the previous section:  cd  ./auth_service/\npython3 manually_register_user.py  You should see that the event gets sent by the  manually_register_user.py  script within the  auth_service , and received by by the  lightbus run  process within the  another_service .",
            "title": "Listening for events"
        },
        {
            "location": "/tutorial/quick-start/#listener-names",
            "text": "You may have noticed we specified the  listener_name  parameter in the above example, \nand we set it to an arbitrary value of  \"print_on_new_registration\" . This is important, because Lightbus tracks \nwhich listeners have received which events. It is this listener name which is used to \nuniquely identify each listener. You don't need to worry about this often, just follow the rule:  Ensure you specify a unique  listener_name  every time you setup a new listener .  The listener name should be unique within the service. Two listeners with the same name \nwill only receive a partial set of events each.",
            "title": "Listener names"
        },
        {
            "location": "/tutorial/quick-start/#25-next",
            "text": "This was a simple example to get you started. The  worked example  considers\na more realistic scenario involving multiple services.",
            "title": "2.5 Next"
        },
        {
            "location": "/tutorial/worked-example/",
            "text": "In the following worked example we will create three services:\n\n\n\n\nAn image resizing service\n\n\nAn online store\n\n\nA stats dashboard\n\n\n\n\nThis will involve a combination of web interfaces (using \nFlask\n), and Lightbus APIs.\nThe goal is to show how Lightbus can allow multiple services to interact.\n\n\n3.1. Getting started\n\u00b6\n\n\nThe code created here can be found in Lightbus example \nex03_worked_example\n, although\nthe code will be repeated below. There is a directory for each service we will\ncreate \u2013 \nstore/\n, \ndashboard/\n, and \nimage/\n.\n\n\nBefore continuing ensure you have installed \nflask\n and \nhoncho\n:\n\n\npip3 install flask honcho\n\n\n\n\n\nA passing familiarity with \nFlask\n may be useful, but is not required. \nHoncho\n\nwill assist us in running the various processes required for our services.\n\n\nWe will assume you\nhave already read and completed the \ninstallation\n and\n\nquick start\n tutorials.\n\n\n3.2. Image resizing service\n\u00b6\n\n\nThe image resizing service will be a simple Lightbus API, the purpose of which\nis to allow our store to resize images prior to display:\n\n\n# File: ./image/bus.py\n\n\nimport\n \nlightbus\n\n\n\nclass\n \nImageApi\n(\nlightbus\n.\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'image'\n\n\n    \ndef\n \nresize\n(\nself\n,\n \nurl\n,\n \nwidth\n,\n \nheight\n):\n\n        \n# This is a demo, so just return an animal picture of the correct size\n\n        \nreturn\n \nf\n'https://placeimg.com/\n{width}\n/\n{height}\n/animals?_=\n{url}\n'\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\nbus\n.\nclient\n.\nregister_api\n(\nImageApi\n)\n\n\n\n\n\nThere is no web interface for this service, so this is all we need.\n\n\n3.3. Store service\n\u00b6\n\n\nOur store will have both a Lightbus API and a web interface. We'll start\nwith the API first:\n\n\n# File: ./store/bus.py\n\n\nimport\n \nlightbus\n\n\n\nclass\n \nStoreApi\n(\nlightbus\n.\nApi\n):\n\n    \npage_viewed\n \n=\n \nlightbus\n.\nEvent\n(\nparameters\n=\n(\n'url'\n,\n \n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'store'\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\nbus\n.\nclient\n.\nregister_api\n(\nStoreApi\n)\n\n\n\n\n\nThis API has a single event called \npage_viewed\n. The store web interface will fire this\nevent whenever a page is viewed.\n\n\nOur store web interface uses Flask and is a little longer:\n\n\n# File: ./store/web.py\n\n\nimport\n \nlightbus\n\n\nfrom\n \nflask\n \nimport\n \nFlask\n\n\n\n# Import our bus client\n\n\nfrom\n \n.bus\n \nimport\n \nbus\n\n\n\n# Setup flask\n\n\napp\n \n=\n \nFlask\n(\n__name__\n)\n\n\n\n# A dummy list of pets our store will sell\n\n\nPETS\n \n=\n \n(\n\n    \n'http://store.company.com/image1.jpg'\n,\n\n    \n'http://store.company.com/image2.jpg'\n,\n\n    \n'http://store.company.com/image3.jpg'\n,\n\n\n)\n\n\n\n@app\n.\nroute\n(\n'/'\n)\n\n\ndef\n \nhome\n():\n\n    \n# A view to list all available pets\n\n    \nhtml\n \n=\n \n'<h1>Online pet store</h1><br>'\n\n\n    \nfor\n \npet_num\n,\n \nimage_url\n \nin\n \nenumerate\n(\nPETS\n):\n\n        \n# Get an image of the appropriate size\n\n        \nresized_url\n \n=\n \nbus\n.\nimage\n.\nresize\n(\nurl\n=\nimage_url\n,\n \nwidth\n=\n200\n,\n \nheight\n=\n200\n)\n\n        \nhtml\n \n+=\n \n(\n\n            \nf\n'<a href=\"/pet/\n{pet_num}\n\">'\n\n            \nf\n'<img src=\"\n{resized_url}\n\">'\n\n            \nf\n'</a> '\n\n        \n)\n\n\n    \n# Fire the page view\n\n    \nbus\n.\nstore\n.\npage_viewed\n.\nfire\n(\nurl\n=\n'/'\n)\n\n\n    \nreturn\n \nhtml\n\n\n\n@app\n.\nroute\n(\n'/pet/<int:pet_num>'\n)\n\n\ndef\n \npet\n(\npet_num\n):\n\n    \n# Show an individual pet\n\n    \nresized_url\n \n=\n \nbus\n.\nimage\n.\nresize\n(\nurl\n=\nPETS\n[\npet_num\n],\n \nwidth\n=\n200\n,\n \nheight\n=\n200\n)\n\n\n    \n# Fire the page view\n\n    \nbus\n.\nstore\n.\npage_viewed\n.\nfire\n(\nurl\n=\nf\n'/pet/\n{pet_num}\n'\n)\n\n\n    \nhtml\n \n=\n \nf\n'<h1>Pet \n{pet_num}\n</h1>'\n\n    \nhtml\n \n=\n \nf\n'<img src=\"\n{resized_url}\n\"><br />'\n\n    \nreturn\n \nhtml\n\n\n\n\n\n3.4. Interlude: give it a go\n\u00b6\n\n\nWe're not quite done yet, but you can now startup the necessary processes and\nsee the store. You will need to run each of these in a separate terminal window:\n\n\n$ ls\nimage/       store/\n\n\n# Start our image resizing service\n\n$ lightbus run --bus\n=\nimage.bus\n\n\n# Start our store's web interface\n\n$ \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\n\n\n\n\nNow open \n127.0.0.1:5001\n in your browser and\nyou should see three animal pictures awaiting you. The URL for each\nimage was fetched from the image resizing service.\n\n\nThe flask web interface should also have some logging output akin to the following:\n\n\n\n\nHere you can see:\n\n\n\n\nimage.resize\n was called three times, once for each image\n\n\nThe \nstore.page_viewed\n event was fired\n\n\n\n\nNext we will create the dashboard which will make use of the \nstore.page_viewed\n event.\n\n\n3.5. Dashboard service\n\u00b6\n\n\nThe dashboard service will provide internal reporting in the form\nof page view statistics for the online store.\n\n\nThere dashboard will need to both receive events and provide a web\ninterface. It will therefore need both a lightbus process and a\nweb process.\n\n\nFist we will start with the \nbus.py\n file:\n\n\n# File: ./dashboard/bus.py\n\n\nimport\n \njson\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\nclient\n()\n\n\npage_views\n \n=\n \n{}\n\n\n\ndef\n \nhandle_page_view\n(\nevent_message\n,\n \nurl\n):\n\n    \n# Record the page view in our page_views dictionary\n\n    \npage_views\n.\nsetdefault\n(\nurl\n,\n \n0\n)\n\n    \npage_views\n[\nurl\n]\n \n+=\n \n1\n\n\n    \n# Store the dictionary on disk\n\n    \n# (In reality you would probably use an external database)\n\n    \nwith\n \nopen\n(\n'/tmp/.dashboard.db.json'\n,\n \n'w'\n)\n \nas\n \nf\n:\n\n        \njson\n.\ndump\n(\npage_views\n,\n \nf\n)\n\n\n\n@bus\n.\nclient\n.\non_start\n()\n\n\ndef\n \non_start\n(\n**\nkwargs\n):\n\n    \n# Called when lightbus starts up\n\n    \nbus\n.\nstore\n.\npage_viewed\n.\nlisten\n(\nhandle_page_view\n)\n\n\n\n\n\nThis is a simple listener for the \nbus.store.page_viewed\n event. This event is fired by the\nstore's web interface we created above.\n\n\nNote we do not define any APIs,\ninstead we setup our event listener once the bus client has started up. Listening for this\nevent is all the dashboard's Lightbus process will do, it will not provide any APIs.\n\n\nThe \nhandle_page_view()\n handler persists each view to the Dashboard services' local database.\nIn a real service this would likely be a DBMS of some form (Postgres, MySQL,\nRedis, Mongo etc). For simplicity we just store JSON to a file.\n\n\nNow we'll define our dashboard's web interface:\n\n\n# File: ./dashboard/web.py\n\n\nimport\n \njson\n\n\nfrom\n \nflask\n \nimport\n \nFlask\n\n\n\napp\n \n=\n \nFlask\n(\n__name__\n)\n\n\n\n@app\n.\nroute\n(\n'/'\n)\n\n\ndef\n \nhome\n():\n\n    \nhtml\n \n=\n \n'<h1>Dashboard</h1>\n\\n\n'\n\n    \nhtml\n \n=\n \n'<p>Total store views</p>\n\\n\n'\n\n\n    \nwith\n \nopen\n(\n'/tmp/.dashboard.db.json'\n,\n \n'r'\n)\n \nas\n \nf\n:\n\n        \npage_views\n \n=\n \njson\n.\nload\n(\nf\n)\n\n\n    \nhtml\n \n+=\n \n'<ul>'\n\n    \nfor\n \nurl\n,\n \ntotal_views\n \nin\n \npage_views\n.\nitems\n():\n\n        \nhtml\n \n+=\n \nf\n'<li>URL <code>\n{url}\n</code>: \n{total_views}\n</li>'\n\n    \nhtml\n \n+=\n \n'</ul>'\n\n\n    \nreturn\n \nhtml\n\n\n\n\n\nThis reads the JSON data that was written by the event listener in \ndashboard/bus.py\n above,\nthen render it to HTML.\n\n\n3.6. Run it!\n\u00b6\n\n\nYou should now have the following python files:\n\n\n./image/bus.py\n./store/bus.py\n./store/web.py\n./dashboard/bus.py\n./dashboard/web.py\n\n\nThis translates into the following processes:\n\n\n\n\n\n\n\n\nService\n\n\nProcess type\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nImage reszier\n\n\nLightbus\n\n\nWill resize images and return a new URL\n\n\n\n\n\n\nStore\n\n\nWeb\n\n\nRender the store UI. Use bus to resize image and fire events\n\n\n\n\n\n\nStore\n\n\nLightbus\n\n\nWhile the store does have a \nbus.py\n, it does not have any RPCs to serve or events to listen for. We therefore do not need to run a lightbus service.\n\n\n\n\n\n\nDashboard\n\n\nWeb\n\n\nRender the dashboard web UI, read data from database\n\n\n\n\n\n\nDashboard\n\n\nLightbus\n\n\nListen for page view events and store stats to database\n\n\n\n\n\n\n\n\nYou can run each of these as follows:\n\n\n$ ls\ndashboard/    image/    store/\n\n\n# Image resizer (Lightbus)\n\n$ lightbus run --bus\n=\nimage.bus\n\n\n# Store (Web)\n\n$ \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\n\n\n# Dashboard (Web + Lightbus)\n\n$ lightbus run --bus\n=\ndashboard.bus\n$ \nFLASK_APP\n=\ndashboard/web.py flask run --port\n=\n5000\n\n\n\n\n\nHowever,\n you may find it easier to startup these processes\nwith the \nhoncho\n tool we installed earlier. First, create\na file called \nProcfile\n:\n\n\n# Procfile\n\nimage_resizer_bus: lightbus run --bus\n=\nimage.bus\nstore_web:         \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\ndashboard_bus:     lightbus run --bus\n=\ndashboard.bus\ndashboard_web:     \nFLASK_APP\n=\ndashboard/web.py flask run --port\n=\n5000\n\n\n\n\n\nAnd now use \nhoncho\n to startup all the processes together:\n\n\n$ ls\nProcfile    dashboard/    image/    store/\n\n$ honcho start\n\n\n\n\nIf you see an error stating \ncommand not found\n, ensure you installed \nhoncho\n as\ndetailed above (\npip3 install honcho\n).\n\n\nOnce started, see the output for any errors. Each log line will state the process\nit came from. If all is well, you should see something like this:\n\n\n\n\nYou should now be able to access the store's web interface at \n127.0.0.1:5001\n as you\ndid previously.\n\n\nUpon viewing the page, the following will happen:\n\n\n\n\nThe store web process will resize each image using the image resizing service\n\n\nThe store web service will fire the \nstore.page_viewed\n event. \n\n\nThe dashboard will receive the \nstore.page_viewed\n event and create the database for the first time. \n\n\n\n\nThe logging output should reflect this:\n\n\n\n\nAt this point you can view the dashboard at \n127.0.0.1:5000\n. Note that opening the dashboard\nbefore this point would have resulted in an error as the database would not have been\ncreated.\n\n\nThe dashboard should show a simple list of URLs plus the total number of page views for each.\nGo back to the store and view a few pages. Now refresh the dashboard and note the new data.\n\n\n3.7. Wrapping up\n\u00b6\n\n\nWhile the services we have have created here are very crude, hopefully they have helped\nshow how Lightbus can be used as a effective communications infrastructure.\n\n\nIf you want to continue with practical learning, you should take a look at the \n\nHow to\n or \nReference\n sections. To learn more about the underlying concepts \nyou should explore the \nExplanation\n section.",
            "title": "3. Worked example"
        },
        {
            "location": "/tutorial/worked-example/#31-getting-started",
            "text": "The code created here can be found in Lightbus example  ex03_worked_example , although\nthe code will be repeated below. There is a directory for each service we will\ncreate \u2013  store/ ,  dashboard/ , and  image/ .  Before continuing ensure you have installed  flask  and  honcho :  pip3 install flask honcho  A passing familiarity with  Flask  may be useful, but is not required.  Honcho \nwill assist us in running the various processes required for our services.  We will assume you\nhave already read and completed the  installation  and quick start  tutorials.",
            "title": "3.1. Getting started"
        },
        {
            "location": "/tutorial/worked-example/#32-image-resizing-service",
            "text": "The image resizing service will be a simple Lightbus API, the purpose of which\nis to allow our store to resize images prior to display:  # File: ./image/bus.py  import   lightbus  class   ImageApi ( lightbus . Api ): \n\n     class   Meta : \n         name   =   'image' \n\n     def   resize ( self ,   url ,   width ,   height ): \n         # This is a demo, so just return an animal picture of the correct size \n         return   f 'https://placeimg.com/ {width} / {height} /animals?_= {url} '  bus   =   lightbus . create ()  bus . client . register_api ( ImageApi )   There is no web interface for this service, so this is all we need.",
            "title": "3.2. Image resizing service"
        },
        {
            "location": "/tutorial/worked-example/#33-store-service",
            "text": "Our store will have both a Lightbus API and a web interface. We'll start\nwith the API first:  # File: ./store/bus.py  import   lightbus  class   StoreApi ( lightbus . Api ): \n     page_viewed   =   lightbus . Event ( parameters = ( 'url' ,   )) \n\n     class   Meta : \n         name   =   'store'  bus   =   lightbus . create ()  bus . client . register_api ( StoreApi )   This API has a single event called  page_viewed . The store web interface will fire this\nevent whenever a page is viewed.  Our store web interface uses Flask and is a little longer:  # File: ./store/web.py  import   lightbus  from   flask   import   Flask  # Import our bus client  from   .bus   import   bus  # Setup flask  app   =   Flask ( __name__ )  # A dummy list of pets our store will sell  PETS   =   ( \n     'http://store.company.com/image1.jpg' , \n     'http://store.company.com/image2.jpg' , \n     'http://store.company.com/image3.jpg' ,  )  @app . route ( '/' )  def   home (): \n     # A view to list all available pets \n     html   =   '<h1>Online pet store</h1><br>' \n\n     for   pet_num ,   image_url   in   enumerate ( PETS ): \n         # Get an image of the appropriate size \n         resized_url   =   bus . image . resize ( url = image_url ,   width = 200 ,   height = 200 ) \n         html   +=   ( \n             f '<a href=\"/pet/ {pet_num} \">' \n             f '<img src=\" {resized_url} \">' \n             f '</a> ' \n         ) \n\n     # Fire the page view \n     bus . store . page_viewed . fire ( url = '/' ) \n\n     return   html  @app . route ( '/pet/<int:pet_num>' )  def   pet ( pet_num ): \n     # Show an individual pet \n     resized_url   =   bus . image . resize ( url = PETS [ pet_num ],   width = 200 ,   height = 200 ) \n\n     # Fire the page view \n     bus . store . page_viewed . fire ( url = f '/pet/ {pet_num} ' ) \n\n     html   =   f '<h1>Pet  {pet_num} </h1>' \n     html   =   f '<img src=\" {resized_url} \"><br />' \n     return   html",
            "title": "3.3. Store service"
        },
        {
            "location": "/tutorial/worked-example/#34-interlude-give-it-a-go",
            "text": "We're not quite done yet, but you can now startup the necessary processes and\nsee the store. You will need to run each of these in a separate terminal window:  $ ls\nimage/       store/ # Start our image resizing service \n$ lightbus run --bus = image.bus # Start our store's web interface \n$  FLASK_APP = store/web.py flask run --port = 5001   Now open  127.0.0.1:5001  in your browser and\nyou should see three animal pictures awaiting you. The URL for each\nimage was fetched from the image resizing service.  The flask web interface should also have some logging output akin to the following:   Here you can see:   image.resize  was called three times, once for each image  The  store.page_viewed  event was fired   Next we will create the dashboard which will make use of the  store.page_viewed  event.",
            "title": "3.4. Interlude: give it a go"
        },
        {
            "location": "/tutorial/worked-example/#35-dashboard-service",
            "text": "The dashboard service will provide internal reporting in the form\nof page view statistics for the online store.  There dashboard will need to both receive events and provide a web\ninterface. It will therefore need both a lightbus process and a\nweb process.  Fist we will start with the  bus.py  file:  # File: ./dashboard/bus.py  import   json  import   lightbus  bus   =   lightbus . client ()  page_views   =   {}  def   handle_page_view ( event_message ,   url ): \n     # Record the page view in our page_views dictionary \n     page_views . setdefault ( url ,   0 ) \n     page_views [ url ]   +=   1 \n\n     # Store the dictionary on disk \n     # (In reality you would probably use an external database) \n     with   open ( '/tmp/.dashboard.db.json' ,   'w' )   as   f : \n         json . dump ( page_views ,   f )  @bus . client . on_start ()  def   on_start ( ** kwargs ): \n     # Called when lightbus starts up \n     bus . store . page_viewed . listen ( handle_page_view )   This is a simple listener for the  bus.store.page_viewed  event. This event is fired by the\nstore's web interface we created above.  Note we do not define any APIs,\ninstead we setup our event listener once the bus client has started up. Listening for this\nevent is all the dashboard's Lightbus process will do, it will not provide any APIs.  The  handle_page_view()  handler persists each view to the Dashboard services' local database.\nIn a real service this would likely be a DBMS of some form (Postgres, MySQL,\nRedis, Mongo etc). For simplicity we just store JSON to a file.  Now we'll define our dashboard's web interface:  # File: ./dashboard/web.py  import   json  from   flask   import   Flask  app   =   Flask ( __name__ )  @app . route ( '/' )  def   home (): \n     html   =   '<h1>Dashboard</h1> \\n ' \n     html   =   '<p>Total store views</p> \\n ' \n\n     with   open ( '/tmp/.dashboard.db.json' ,   'r' )   as   f : \n         page_views   =   json . load ( f ) \n\n     html   +=   '<ul>' \n     for   url ,   total_views   in   page_views . items (): \n         html   +=   f '<li>URL <code> {url} </code>:  {total_views} </li>' \n     html   +=   '</ul>' \n\n     return   html   This reads the JSON data that was written by the event listener in  dashboard/bus.py  above,\nthen render it to HTML.",
            "title": "3.5. Dashboard service"
        },
        {
            "location": "/tutorial/worked-example/#36-run-it",
            "text": "You should now have the following python files:  ./image/bus.py\n./store/bus.py\n./store/web.py\n./dashboard/bus.py\n./dashboard/web.py  This translates into the following processes:     Service  Process type  Purpose      Image reszier  Lightbus  Will resize images and return a new URL    Store  Web  Render the store UI. Use bus to resize image and fire events    Store  Lightbus  While the store does have a  bus.py , it does not have any RPCs to serve or events to listen for. We therefore do not need to run a lightbus service.    Dashboard  Web  Render the dashboard web UI, read data from database    Dashboard  Lightbus  Listen for page view events and store stats to database     You can run each of these as follows:  $ ls\ndashboard/    image/    store/ # Image resizer (Lightbus) \n$ lightbus run --bus = image.bus # Store (Web) \n$  FLASK_APP = store/web.py flask run --port = 5001  # Dashboard (Web + Lightbus) \n$ lightbus run --bus = dashboard.bus\n$  FLASK_APP = dashboard/web.py flask run --port = 5000   However,  you may find it easier to startup these processes\nwith the  honcho  tool we installed earlier. First, create\na file called  Procfile :  # Procfile \nimage_resizer_bus: lightbus run --bus = image.bus\nstore_web:          FLASK_APP = store/web.py flask run --port = 5001 \ndashboard_bus:     lightbus run --bus = dashboard.bus\ndashboard_web:      FLASK_APP = dashboard/web.py flask run --port = 5000   And now use  honcho  to startup all the processes together:  $ ls\nProcfile    dashboard/    image/    store/\n\n$ honcho start  If you see an error stating  command not found , ensure you installed  honcho  as\ndetailed above ( pip3 install honcho ).  Once started, see the output for any errors. Each log line will state the process\nit came from. If all is well, you should see something like this:   You should now be able to access the store's web interface at  127.0.0.1:5001  as you\ndid previously.  Upon viewing the page, the following will happen:   The store web process will resize each image using the image resizing service  The store web service will fire the  store.page_viewed  event.   The dashboard will receive the  store.page_viewed  event and create the database for the first time.    The logging output should reflect this:   At this point you can view the dashboard at  127.0.0.1:5000 . Note that opening the dashboard\nbefore this point would have resulted in an error as the database would not have been\ncreated.  The dashboard should show a simple list of URLs plus the total number of page views for each.\nGo back to the store and view a few pages. Now refresh the dashboard and note the new data.",
            "title": "3.6. Run it!"
        },
        {
            "location": "/tutorial/worked-example/#37-wrapping-up",
            "text": "While the services we have have created here are very crude, hopefully they have helped\nshow how Lightbus can be used as a effective communications infrastructure.  If you want to continue with practical learning, you should take a look at the  How to  or  Reference  sections. To learn more about the underlying concepts \nyou should explore the  Explanation  section.",
            "title": "3.7. Wrapping up"
        },
        {
            "location": "/howto/",
            "text": "Howto overview\n\u00b6\n\n\nIn this section we address \nspecific problems and common use cases\n.\nAs with the \ntutorials\n we will link to concepts as we go, but the\npriority here is to provide a clear path to a solution.",
            "title": "Overview"
        },
        {
            "location": "/howto/#howto-overview",
            "text": "In this section we address  specific problems and common use cases .\nAs with the  tutorials  we will link to concepts as we go, but the\npriority here is to provide a clear path to a solution.",
            "title": "Howto overview"
        },
        {
            "location": "/howto/access-your-bus-client/",
            "text": "How to access your bus client\n\u00b6\n\n\nYou create your bus client in your bus module\n(typically called \nbus.py\n) with the line:\n\n\n# Creating your bus client in your bus.py file\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n\n\nHowever, you will often need to make use of your bus client\nin other areas of your codebase. For example, you may need to\nfire an event when a web form is submitted.\n\n\nYou can access the bus client in two ways.\n\n\nMethod 1: Direct import (recommended)\n\u00b6\n\n\nThe first approach is to import your bus client directly from\nyour bus module, in the same way you would import anything else\nin your codebase:\n\n\n# For example\n\n\nfrom\n \nbus\n \nimport\n \nbus\n\n\n\n# ...or if your service has its own package\n\n\nfrom\n \nmy_service.bus\n \nimport\n \nbus\n\n\n\n\n\nYou should use this approach in code which is specific to your\nservice (i.e. non-shared/non-library code). This approach is more\nexplicit (good), but hard codes the path to your bus module (bad for shared code).\n\n\nMethod 2: \nget_bus()\n\u00b6\n\n\nThe second approach uses the \nlightbus.get_bus()\n function. This will\nuse the \nmodule loading configuration\n to determine the bus module location.\nIf the bus module has already been imported, then the module's\n\nbus\n attribute will simply be returned. Otherwise the bus module will be\nimported first.\n\n\n# Anywhere in your codebase\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\nget_bus\n()\n\n\n\n\n\nThis approach is best suited to when you do not know where your bus module\nwill be at runtime. This could be the case when:\n\n\n\n\nWriting shared code which is used by multiple services\n\n\nWriting a third party library",
            "title": "Access your bus client"
        },
        {
            "location": "/howto/access-your-bus-client/#how-to-access-your-bus-client",
            "text": "You create your bus client in your bus module\n(typically called  bus.py ) with the line:  # Creating your bus client in your bus.py file  import   lightbus  bus   =   lightbus . create ()   However, you will often need to make use of your bus client\nin other areas of your codebase. For example, you may need to\nfire an event when a web form is submitted.  You can access the bus client in two ways.",
            "title": "How to access your bus client"
        },
        {
            "location": "/howto/access-your-bus-client/#method-1-direct-import-recommended",
            "text": "The first approach is to import your bus client directly from\nyour bus module, in the same way you would import anything else\nin your codebase:  # For example  from   bus   import   bus  # ...or if your service has its own package  from   my_service.bus   import   bus   You should use this approach in code which is specific to your\nservice (i.e. non-shared/non-library code). This approach is more\nexplicit (good), but hard codes the path to your bus module (bad for shared code).",
            "title": "Method 1: Direct import (recommended)"
        },
        {
            "location": "/howto/access-your-bus-client/#method-2-get_bus",
            "text": "The second approach uses the  lightbus.get_bus()  function. This will\nuse the  module loading configuration  to determine the bus module location.\nIf the bus module has already been imported, then the module's bus  attribute will simply be returned. Otherwise the bus module will be\nimported first.  # Anywhere in your codebase  import   lightbus  bus   =   lightbus . get_bus ()   This approach is best suited to when you do not know where your bus module\nwill be at runtime. This could be the case when:   Writing shared code which is used by multiple services  Writing a third party library",
            "title": "Method 2: get_bus()"
        },
        {
            "location": "/howto/schedule-recurring-tasks/",
            "text": "How to schedule recurring tasks\n\u00b6\n\n\nRecurring tasks can be scheduled in two ways:\n\n\n\n\nThe \n@bus.client.every()\n decorator \u2013 Will execute a function or coroutine at a given interval\n\n\nThe \n@bus.client.schedule()\n decorator \u2013 Similar to \nevery()\n, but takes complex schedules as provided by the \nschedule\n library.\n\n\n\n\nSimple recurring tasks using \n@bus.client.every()\n\u00b6\n\n\nLightbus natively supports simple recurring tasks using the \n@bus.client.every()\n decorator:\n\n\n# bus.py\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n@bus\n.\nclient\n.\nevery\n(\nseconds\n=\n1\n)\n\n\ndef\n \ndo_it\n():\n\n    \nprint\n(\n\"Hello!\"\n)\n\n\n\n\n\nThe interval can be specified using the \nseconds\n, \nminutes\n, \nhours\n, and \ndays\n keys.\nPass \nalso_run_immediately=True\n to execute the function/coroutine immediately, as well as \nat the given interval.\n\n\nComplex schedules using \n@bus.client.schedule()\n\u00b6\n\n\nLightbus also supports using schedules specified using \nthe \nschedule\n library. This allows for schedules \nsuch as 'every Monday at 1am', rather than simple intervals.\nFor example:\n\n\nimport\n \nlightbus\n\n\nimport\n \nschedule\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Run the task every 1-3 seconds, varying randomly\n\n\n@bus\n.\nclient\n.\nschedule\n(\nschedule\n.\nevery\n(\n1\n)\n.\nto\n(\n3\n)\n.\nseconds\n)\n\n\ndef\n \ndo_it\n():\n\n    \nprint\n(\n\"Hello using schedule library\"\n)",
            "title": "Schedule recurring tasks"
        },
        {
            "location": "/howto/schedule-recurring-tasks/#how-to-schedule-recurring-tasks",
            "text": "Recurring tasks can be scheduled in two ways:   The  @bus.client.every()  decorator \u2013 Will execute a function or coroutine at a given interval  The  @bus.client.schedule()  decorator \u2013 Similar to  every() , but takes complex schedules as provided by the  schedule  library.",
            "title": "How to schedule recurring tasks"
        },
        {
            "location": "/howto/schedule-recurring-tasks/#simple-recurring-tasks-using-busclientevery",
            "text": "Lightbus natively supports simple recurring tasks using the  @bus.client.every()  decorator:  # bus.py  import   lightbus  bus   =   lightbus . create ()  @bus . client . every ( seconds = 1 )  def   do_it (): \n     print ( \"Hello!\" )   The interval can be specified using the  seconds ,  minutes ,  hours , and  days  keys.\nPass  also_run_immediately=True  to execute the function/coroutine immediately, as well as \nat the given interval.",
            "title": "Simple recurring tasks using @bus.client.every()"
        },
        {
            "location": "/howto/schedule-recurring-tasks/#complex-schedules-using-busclientschedule",
            "text": "Lightbus also supports using schedules specified using \nthe  schedule  library. This allows for schedules \nsuch as 'every Monday at 1am', rather than simple intervals.\nFor example:  import   lightbus  import   schedule  bus   =   lightbus . create ()  # Run the task every 1-3 seconds, varying randomly  @bus . client . schedule ( schedule . every ( 1 ) . to ( 3 ) . seconds )  def   do_it (): \n     print ( \"Hello using schedule library\" )",
            "title": "Complex schedules using @bus.client.schedule()"
        },
        {
            "location": "/howto/run-background-tasks/",
            "text": "How to run background tasks\n\u00b6\n\n\nSometimes you may wish to run arbitrary \nasyncio\n tasks in the background of the \n\nlightbus run\n process. You can set these up in your \nbus.py\n file:\n\n\n# bus.py\n\n\nimport\n \nasyncio\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\nasync\n \ndef\n \nmy_background_task\n():\n\n    \nwhile\n \nTrue\n:\n\n        \nawait\n \nasyncio\n.\nsleep\n(\n1\n)\n\n        \nprint\n(\n\"Hello!\"\n)\n\n\n\n@bus\n.\nclient\n.\non_start\n()\n\n\ndef\n \non_startup\n(\n**\nkwargs\n):\n\n    \nbus\n.\nclient\n.\nadd_background_task\n(\nmy_background_task\n())\n\n\n\n\n\nImportant points to note are:\n\n\n\n\nThe background task will be automatically cancelled when the bus is closed.\n  You can disable this by passing \ncancel_on_close=False\n.\n\n\nAny errors in the background task will be bubbled up and cause the \n  Lightbus process to exit. If this is not desired you can implement \n  your own try/except handling within the function being executed.\n\n\n\n\n\n\nNote\n\n\nIf you wish to schedule a recurring task then you should probably use \n\n@bus.client.every()\n or \n@bus.client.schedule()\n. See \n\nhow to schedule recurring tasks\n.",
            "title": "Run background tasks"
        },
        {
            "location": "/howto/run-background-tasks/#how-to-run-background-tasks",
            "text": "Sometimes you may wish to run arbitrary  asyncio  tasks in the background of the  lightbus run  process. You can set these up in your  bus.py  file:  # bus.py  import   asyncio  import   lightbus  bus   =   lightbus . create ()  async   def   my_background_task (): \n     while   True : \n         await   asyncio . sleep ( 1 ) \n         print ( \"Hello!\" )  @bus . client . on_start ()  def   on_startup ( ** kwargs ): \n     bus . client . add_background_task ( my_background_task ())   Important points to note are:   The background task will be automatically cancelled when the bus is closed.\n  You can disable this by passing  cancel_on_close=False .  Any errors in the background task will be bubbled up and cause the \n  Lightbus process to exit. If this is not desired you can implement \n  your own try/except handling within the function being executed.    Note  If you wish to schedule a recurring task then you should probably use  @bus.client.every()  or  @bus.client.schedule() . See  how to schedule recurring tasks .",
            "title": "How to run background tasks"
        },
        {
            "location": "/howto/metrics/",
            "text": "How to use Lightbus for metrics\n\u00b6\n\n\nNotes to be expanded upon:\n\n\n\n\nOptimising for throughput and performance. Assuming lost messages are acceptable.\n\n\nDisable all validation\n\n\non_error=ignore\n\n\nFuture development: Redis PUB/SUB transport?\n\n\ncast_values=false\n - You'll receive basic JSON values in the event listeners, but it'll be faster",
            "title": "Use Lightbus for realtime metrics*"
        },
        {
            "location": "/howto/metrics/#how-to-use-lightbus-for-metrics",
            "text": "Notes to be expanded upon:   Optimising for throughput and performance. Assuming lost messages are acceptable.  Disable all validation  on_error=ignore  Future development: Redis PUB/SUB transport?  cast_values=false  - You'll receive basic JSON values in the event listeners, but it'll be faster",
            "title": "How to use Lightbus for metrics"
        },
        {
            "location": "/howto/event-sourcing/",
            "text": "How to use Lightbus for event sourcing\n\u00b6\n\n\nNotes to be expanded upon:\n\n\n\n\nWe are optimising for reliability and completeness\n\n\nSpecify consumer group to event listeners\n\n\nValidate outgoing messages, do not validate incoming messages\n\n\nSet \nmax_stream_length\n high (or to \nnull\n)\n\n\nTransactional transport where an RDBMS is written to in event handlers (experimental)\n\n\non_error=shutdown",
            "title": "Use Lightbus for event sourcing*"
        },
        {
            "location": "/howto/event-sourcing/#how-to-use-lightbus-for-event-sourcing",
            "text": "Notes to be expanded upon:   We are optimising for reliability and completeness  Specify consumer group to event listeners  Validate outgoing messages, do not validate incoming messages  Set  max_stream_length  high (or to  null )  Transactional transport where an RDBMS is written to in event handlers (experimental)  on_error=shutdown",
            "title": "How to use Lightbus for event sourcing"
        },
        {
            "location": "/howto/write-idempotent-event-handlers/",
            "text": "How to write idempotent event handlers\n\u00b6\n\n\nTODO.",
            "title": "Write idempotent event handlers*"
        },
        {
            "location": "/howto/write-idempotent-event-handlers/#how-to-write-idempotent-event-handlers",
            "text": "TODO.",
            "title": "How to write idempotent event handlers"
        },
        {
            "location": "/howto/combine-processes/",
            "text": "How to combine processes\n\u00b6\n\n\nHere we will build on the dashboard we created in the \nworked example\n tutorial.\n\n\nThis \nhow to\n requires some knowledge of Python's asyncio features.\n\n\n\n\nWarning\n\n\nYou can use Lightbus perfectly well without adding this complexity.\n\nSee the \nanatomy lesson\n for additional discussion.\n\n\n\n\n\n\nBehind the scenes Lightbus is powered by Python's asyncio library. Therefore,\nwe can combine the Lightbus and web processes if we use an asyncio-based web server.\nIn this case we'll use \naiohttp\n as our web server, rather than\nFlask which we used earlier.\n\n\n\"\"\" Lightbus & web server operating in a single process\n\n\n    (dashboard/combined.py)\n\n\n\"\"\"\n\n\nimport\n \nlightbus\n\n\nfrom\n \naiohttp\n \nimport\n \nweb\n\n\n\n# Note we no longer need to store page view data on disk.\n\n\n# We simply hold it in memory using a dictionary.\n\n\npage_views\n \n=\n \n{}\n\n\n\n\ndef\n \nhome_view\n(\nrequest\n):\n\n    \n\"\"\"Render the simple dashboard UI\"\"\"\n\n    \nhtml\n \n=\n \n'<h1>Dashboard</h1>\n\\n\n'\n\n    \nhtml\n \n+=\n \n'<p>Total store views</p>\n\\n\n'\n\n\n    \nhtml\n \n+=\n \n'<ul>'\n\n    \n# Read the page views from our `page_views` global variable\n\n    \nfor\n \nurl\n,\n \ntotal_views\n \nin\n \npage_views\n.\nitems\n():\n\n        \nhtml\n \n+=\n \nf\n'<li>URL <code>\n{url}\n</code>: \n{total_views}\n views</li>'\n\n    \nhtml\n \n+=\n \n'</ul>'\n\n\n    \nreturn\n \nweb\n.\nResponse\n(\nbody\n=\nhtml\n,\n \ncontent_type\n=\n'text/html'\n)\n\n\n\n\ndef\n \nhandle_page_view\n(\nevent_message\n,\n \nurl\n):\n\n    \n\"\"\"Handle an incoming page view\"\"\"\n\n    \npage_views\n.\nsetdefault\n(\nurl\n,\n \n0\n)\n\n    \n# Store the incoming view in our `page_views` global variable\n\n    \npage_views\n[\nurl\n]\n \n+=\n \n1\n\n\n\n\nasync\n \ndef\n \nstart_listener\n(\napp\n):\n\n    \n# Create the asyncio task which will listen for the page_view event\n\n    \nlistener_task\n \n=\n \nawait\n \napp\n.\nbus\n.\nstore\n.\npage_view\n.\nlisten_async\n(\nhandle_page_view\n)\n\n\n    \n# Store the task against `app` in case we need it later (hint: we don't)\n\n    \napp\n[\n'page_view_listener'\n]\n \n=\n \nlistener_task\n\n\n\n\nasync\n \ndef\n \ncleanup\n(\napp\n):\n\n    \n# We're using aiohttp to manage the event loop, so\n\n    \n# we need to close up the lightbus client manually on shutdown.\n\n    \n# This will cancel any listeners and close down the redis connections.\n\n    \n# If don't do this you'll see errors on shutdown.\n\n    \nawait\n \napp\n.\nbus\n.\nbus_client\n.\nclose_async\n()\n\n\n\n\ndef\n \nmain\n():\n\n    \n# Make sure Lightbus formats its logs correctly\n\n    \nlightbus\n.\nconfigure_logging\n()\n\n\n    \n# Create our lightbus client and our web application\n\n    \nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n    \napp\n \n=\n \nweb\n.\nApplication\n()\n\n\n    \napp\n.\nrouter\n.\nadd_route\n(\n'GET'\n,\n \n'/'\n,\n \nhome_view\n)\n\n    \napp\n.\non_startup\n.\nappend\n(\nstart_listener\n)\n\n    \napp\n.\non_cleanup\n.\nappend\n(\ncleanup\n)\n\n\n    \n# Store the bus on `app` as we'll need it\n\n    \n# in start_listener() and cleanup()\n\n    \napp\n.\nbus\n \n=\n \nbus\n\n\n    \nweb\n.\nrun_app\n(\napp\n,\n \nhost\n=\n'127.0.0.1'\n,\n \nport\n=\n5000\n)\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nmain\n()\n\n\n\n\n\nNew create a new Procfile called \nProcfile_combined\n. This will use your new combined\ndashboard process along with the existing image resizer and store services:\n\n\n# Procfile_combined\n\n\nimage_resizer_bus: lightbus run --bus\n=\nimage.bus\nstore_web: \nFLASK_DEBUG\n=\n1\n \nFLASK_APP\n=\nstore/web.py flask run --port\n=\n5001\n\n\ndashboard_combined: python dashboard/combined.py\n\n\n\n\nNote that the \ndashboard_web\n and \ndashboard_lightbus\n have gone and \ndashboard_combined\n\nhas been added.\n\n\nYou can now start up your new collection of services using:\n\n\n$ ls\nProcfile    Procfile_combined    dashboard/    image/    store/\n\n$ honcho start -f Procfile_combined",
            "title": "Combine processes"
        },
        {
            "location": "/howto/combine-processes/#how-to-combine-processes",
            "text": "Here we will build on the dashboard we created in the  worked example  tutorial.  This  how to  requires some knowledge of Python's asyncio features.   Warning  You can use Lightbus perfectly well without adding this complexity. \nSee the  anatomy lesson  for additional discussion.    Behind the scenes Lightbus is powered by Python's asyncio library. Therefore,\nwe can combine the Lightbus and web processes if we use an asyncio-based web server.\nIn this case we'll use  aiohttp  as our web server, rather than\nFlask which we used earlier.  \"\"\" Lightbus & web server operating in a single process      (dashboard/combined.py)  \"\"\"  import   lightbus  from   aiohttp   import   web  # Note we no longer need to store page view data on disk.  # We simply hold it in memory using a dictionary.  page_views   =   {}  def   home_view ( request ): \n     \"\"\"Render the simple dashboard UI\"\"\" \n     html   =   '<h1>Dashboard</h1> \\n ' \n     html   +=   '<p>Total store views</p> \\n ' \n\n     html   +=   '<ul>' \n     # Read the page views from our `page_views` global variable \n     for   url ,   total_views   in   page_views . items (): \n         html   +=   f '<li>URL <code> {url} </code>:  {total_views}  views</li>' \n     html   +=   '</ul>' \n\n     return   web . Response ( body = html ,   content_type = 'text/html' )  def   handle_page_view ( event_message ,   url ): \n     \"\"\"Handle an incoming page view\"\"\" \n     page_views . setdefault ( url ,   0 ) \n     # Store the incoming view in our `page_views` global variable \n     page_views [ url ]   +=   1  async   def   start_listener ( app ): \n     # Create the asyncio task which will listen for the page_view event \n     listener_task   =   await   app . bus . store . page_view . listen_async ( handle_page_view ) \n\n     # Store the task against `app` in case we need it later (hint: we don't) \n     app [ 'page_view_listener' ]   =   listener_task  async   def   cleanup ( app ): \n     # We're using aiohttp to manage the event loop, so \n     # we need to close up the lightbus client manually on shutdown. \n     # This will cancel any listeners and close down the redis connections. \n     # If don't do this you'll see errors on shutdown. \n     await   app . bus . bus_client . close_async ()  def   main (): \n     # Make sure Lightbus formats its logs correctly \n     lightbus . configure_logging () \n\n     # Create our lightbus client and our web application \n     bus   =   lightbus . create () \n     app   =   web . Application () \n\n     app . router . add_route ( 'GET' ,   '/' ,   home_view ) \n     app . on_startup . append ( start_listener ) \n     app . on_cleanup . append ( cleanup ) \n\n     # Store the bus on `app` as we'll need it \n     # in start_listener() and cleanup() \n     app . bus   =   bus \n\n     web . run_app ( app ,   host = '127.0.0.1' ,   port = 5000 )  if   __name__   ==   '__main__' : \n     main ()   New create a new Procfile called  Procfile_combined . This will use your new combined\ndashboard process along with the existing image resizer and store services:  # Procfile_combined \n\nimage_resizer_bus: lightbus run --bus = image.bus\nstore_web:  FLASK_DEBUG = 1   FLASK_APP = store/web.py flask run --port = 5001  dashboard_combined: python dashboard/combined.py  Note that the  dashboard_web  and  dashboard_lightbus  have gone and  dashboard_combined \nhas been added.  You can now start up your new collection of services using:  $ ls\nProcfile    Procfile_combined    dashboard/    image/    store/\n\n$ honcho start -f Procfile_combined",
            "title": "How to combine processes"
        },
        {
            "location": "/explanation/",
            "text": "Explanation overview\n\u00b6\n\n\nThis section discusses the \ntheoretical and conceptual aspects\nof Lightbus\n. This is in contrast to the more practical\n\ntutorial\n and \nhow to\n sections.",
            "title": "Overview"
        },
        {
            "location": "/explanation/#explanation-overview",
            "text": "This section discusses the  theoretical and conceptual aspects\nof Lightbus . This is in contrast to the more practical tutorial  and  how to  sections.",
            "title": "Explanation overview"
        },
        {
            "location": "/explanation/anatomy-lesson/",
            "text": "Anatomy lesson\n\u00b6\n\n\nLightbus provides you with two tools:\n\n\n\n\nA \nclient\n with which to fire events, listen for events\n  and make remote procedure calls (RPCs).\n\n\nA \nstand-alone Lightbus worker process\n in which you can setup\n  event listeners. This process will also respond to RPCs calls.\n\n\n\n\n\n\nThe client\n\u00b6\n\n\nThe client allows you to interact with the bus from within your Python\ncodebase. For example:\n\n\n## Creation in bus.py ##\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n\n## Example uses ##\n\n\n\n# Perform a remote procedure call\n\n\nis_valid\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\n\n    \nuser\n=\n\"admin\"\n,\n\n    \npassword\n=\n\"secret\"\n\n\n)\n\n\n\n# Fire an event\n\n\nbus\n.\nauth\n.\nuser_registered\n(\n\n    \nuser\n=\n\"sally\"\n,\n\n    \nemail\n=\n\"sally@example.com\"\n\n\n)\n\n\n\n\n\nYou can use this client anywhere you need to, such as:\n\n\n\n\nWithin your Django/Flask views\n\n\nWithin scheduled jobs\n\n\nWithin Lightbus event & RPC handlers (see below)\n\n\n\n\n\n\nImportant\n\n\nEach service should create its bus client with the service's bus module (ie. the service's \nbus.py\n file). \nOther modules in the service should import the bus client from the bus module as needed.\nSee \nhow to access your bus client\n.\n\n\n\n\nThe Lightbus worker process (\nlightbus run\n)\n\u00b6\n\n\nThe Lightbus worker is a long running process started using \nlightbus run\n. \nThis process serves two purposes:\n\n\n\n\nListens for events and fires any executes any listeners you have created.\n\n\nRespond to incoming remote procedure calls for the service's registered APIs.\n\n\n\n\nThis process imports your bus module (see the \nmodule loading configuration\n reference) \nin order to bootstrap itself. Your bus module should therefore\n\n\n\n\nInstantiate the \nbus\n client in a module variable named \nbus\n\n\nRegister any API definitions for your service\n\n\nSetup listeners for any events you wish to listen for\n\n\n\n\nFor example, let's use the \nauth.create_user()\n remote procedure call\nto create a new user every time a \ncustomers.new_customer\n event appears on the\nbus:\n\n\n# bus.py\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\ndef\n \ncreate_user_for_customer\n(\nevent_message\n,\n\n                             \ncustomer_name\n,\n \nemail\n):\n\n    \n# We can do something locally, or call an\n\n    \n# RPC, or both. Here we call an RPC.\n\n    \nbus\n.\nauth\n.\ncreate_user\n(\n\n        \nname\n=\ncustomer_name\n,\n\n        \nemail\n=\nemail\n\n    \n)\n\n\n\n# Setup our listeners on startup\n\n\n@bus\n.\nclient\n.\non_start\n()\n\n\ndef\n \non_start\n():\n\n    \n# Create a new user for each new customer\n\n    \nbus\n.\ncustomers\n.\nnew_customer\n.\nlisten\n(\n\n        \ncreate_user_for_customer\n\n    \n)\n\n\n\n\n\nYou start this process using the command:\n\n\nlightbus run\n\n\n\n\n\nLightbus will import the bus module (your \nbus.py\n file) and wait\nfor incoming events and remote procedure calls.\n\n\nA service\nwill only need a Lightbus process if it wishes to listen\nfor \nevents\n or provide any \nRPCs\n which can be called.\n\n\nAddendum\n\u00b6\n\n\nThe distinction between client & Lightbus process as described above\nis convention rather than a technical requirement.\n\n\nWhile you will need the client regardless, \nyou can start the Lightbus\nserver in a more advanced fashion\n.\n\n\nThe Lightbus process executes within the \nasyncio\n event loop. You\ncan therefore merge the Lightbus process with any other process which\nalso runs within the \nasyncio\n event loop.\n\n\nThis does however add complexity, and the rewards are likely limited.\nTherefore only pursue this path if you are sure it suits your\nparticular needs.",
            "title": "Anatomy lesson"
        },
        {
            "location": "/explanation/anatomy-lesson/#anatomy-lesson",
            "text": "Lightbus provides you with two tools:   A  client  with which to fire events, listen for events\n  and make remote procedure calls (RPCs).  A  stand-alone Lightbus worker process  in which you can setup\n  event listeners. This process will also respond to RPCs calls.",
            "title": "Anatomy lesson"
        },
        {
            "location": "/explanation/anatomy-lesson/#the-client",
            "text": "The client allows you to interact with the bus from within your Python\ncodebase. For example:  ## Creation in bus.py ##  import   lightbus  bus   =   lightbus . create ()  ## Example uses ##  # Perform a remote procedure call  is_valid   =   bus . auth . check_password ( \n     user = \"admin\" , \n     password = \"secret\"  )  # Fire an event  bus . auth . user_registered ( \n     user = \"sally\" , \n     email = \"sally@example.com\"  )   You can use this client anywhere you need to, such as:   Within your Django/Flask views  Within scheduled jobs  Within Lightbus event & RPC handlers (see below)    Important  Each service should create its bus client with the service's bus module (ie. the service's  bus.py  file). \nOther modules in the service should import the bus client from the bus module as needed.\nSee  how to access your bus client .",
            "title": "The client"
        },
        {
            "location": "/explanation/anatomy-lesson/#the-lightbus-worker-process-lightbus-run",
            "text": "The Lightbus worker is a long running process started using  lightbus run . \nThis process serves two purposes:   Listens for events and fires any executes any listeners you have created.  Respond to incoming remote procedure calls for the service's registered APIs.   This process imports your bus module (see the  module loading configuration  reference) \nin order to bootstrap itself. Your bus module should therefore   Instantiate the  bus  client in a module variable named  bus  Register any API definitions for your service  Setup listeners for any events you wish to listen for   For example, let's use the  auth.create_user()  remote procedure call\nto create a new user every time a  customers.new_customer  event appears on the\nbus:  # bus.py  import   lightbus  bus   =   lightbus . create ()  def   create_user_for_customer ( event_message , \n                              customer_name ,   email ): \n     # We can do something locally, or call an \n     # RPC, or both. Here we call an RPC. \n     bus . auth . create_user ( \n         name = customer_name , \n         email = email \n     )  # Setup our listeners on startup  @bus . client . on_start ()  def   on_start (): \n     # Create a new user for each new customer \n     bus . customers . new_customer . listen ( \n         create_user_for_customer \n     )   You start this process using the command:  lightbus run  Lightbus will import the bus module (your  bus.py  file) and wait\nfor incoming events and remote procedure calls.  A service\nwill only need a Lightbus process if it wishes to listen\nfor  events  or provide any  RPCs  which can be called.",
            "title": "The Lightbus worker process (lightbus run)"
        },
        {
            "location": "/explanation/anatomy-lesson/#addendum",
            "text": "The distinction between client & Lightbus process as described above\nis convention rather than a technical requirement.  While you will need the client regardless,  you can start the Lightbus\nserver in a more advanced fashion .  The Lightbus process executes within the  asyncio  event loop. You\ncan therefore merge the Lightbus process with any other process which\nalso runs within the  asyncio  event loop.  This does however add complexity, and the rewards are likely limited.\nTherefore only pursue this path if you are sure it suits your\nparticular needs.",
            "title": "Addendum"
        },
        {
            "location": "/explanation/services/",
            "text": "Services\n\u00b6\n\n\nA \nservice\n is one or more processes handling a common task.\nThese processes operate as a tightly-coupled whole.\n\n\nAll processes in a service will generally:\n\n\n\n\nShare the same API class definitions\n\n\nMoreover, they will normally share the same codebase\n\n\nCreate a single instance of the bus client in \nbus.py\n using\n  \nbus = lightbus.create()\n.\n\n\n\n\n\n\nFor example, your company may have the following:\n\n\n\n\nAn online store\n\n\nA price monitoring script\n\n\nAn image resizing resizing process \n\n\n\n\nEach of these would be a service.\n\n\nThe store service would have a web process and a\nLightbus process. The image resizing service & and price monitoring services \nwould each likely have a Lightbus process only.\n\n\nA simple lightbus deployment could therefore look something like this:\n\n\n\n\nIn this example the following actions would take place:\n\n\n\n\nDjango reads from the web service database in order to serve web content\n\n\nThe online shop's Lightbus process receives pricing events from the\n  price monitoring service. It updates products in the database using\n  this new pricing data.\n\n\nWhen the Django app receives an image upload, it performs a RPC to the\n  image resizing service to resize the image\n1\n.\n\n\n\n\n\n\n\n\n\n\n\n\nMaking the Django process wait for an RPC to respond is\n  probably a bad idea in this case, but it illustrates how it\n  \ncould\n be done. Using an event (which is fire-and-forget)\n  could be more suitable in reality.\u00a0\n\u21a9",
            "title": "Services"
        },
        {
            "location": "/explanation/services/#services",
            "text": "A  service  is one or more processes handling a common task.\nThese processes operate as a tightly-coupled whole.  All processes in a service will generally:   Share the same API class definitions  Moreover, they will normally share the same codebase  Create a single instance of the bus client in  bus.py  using\n   bus = lightbus.create() .    For example, your company may have the following:   An online store  A price monitoring script  An image resizing resizing process    Each of these would be a service.  The store service would have a web process and a\nLightbus process. The image resizing service & and price monitoring services \nwould each likely have a Lightbus process only.  A simple lightbus deployment could therefore look something like this:   In this example the following actions would take place:   Django reads from the web service database in order to serve web content  The online shop's Lightbus process receives pricing events from the\n  price monitoring service. It updates products in the database using\n  this new pricing data.  When the Django app receives an image upload, it performs a RPC to the\n  image resizing service to resize the image 1 .       Making the Django process wait for an RPC to respond is\n  probably a bad idea in this case, but it illustrates how it\n   could  be done. Using an event (which is fire-and-forget)\n  could be more suitable in reality.\u00a0 \u21a9",
            "title": "Services"
        },
        {
            "location": "/explanation/bus/",
            "text": "The bus\n\u00b6\n\n\nThe bus is the communications channel which links all your\nservices together. Currently this is Redis.\n\n\nYou use \nlightbus.create()\n in your \nbus.py\n file to access\nthis bus:\n\n\n# bus.py\n\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n\n\nThis creates a high-level client through which you can\nperform \nremote procedure calls\n and fire \nevents\n.\n\n\nAbout buses\n\u00b6\n\n\nIn computing, a bus is a shared communication medium. A bus allows any\nsoftware/hardware connected to that medium to communicate, as long as\ncommon rules are obeyed. In this sense a bus is very similar to a conversation\nbetween a group of people.\n\n\nIn electronics the communication medium can be a simple\ncopper cable. In software the communication medium is itself defined\nby software.\n\n\nLightbus uses Redis as its communication medium\n, although support\nfor other mediums may be added in future.",
            "title": "The bus"
        },
        {
            "location": "/explanation/bus/#the-bus",
            "text": "The bus is the communications channel which links all your\nservices together. Currently this is Redis.  You use  lightbus.create()  in your  bus.py  file to access\nthis bus:  # bus.py  import   lightbus  bus   =   lightbus . create ()   This creates a high-level client through which you can\nperform  remote procedure calls  and fire  events .",
            "title": "The bus"
        },
        {
            "location": "/explanation/bus/#about-buses",
            "text": "In computing, a bus is a shared communication medium. A bus allows any\nsoftware/hardware connected to that medium to communicate, as long as\ncommon rules are obeyed. In this sense a bus is very similar to a conversation\nbetween a group of people.  In electronics the communication medium can be a simple\ncopper cable. In software the communication medium is itself defined\nby software.  Lightbus uses Redis as its communication medium , although support\nfor other mediums may be added in future.",
            "title": "About buses"
        },
        {
            "location": "/explanation/apis/",
            "text": "APIs\n\u00b6\n\n\nWhen we refer to an \nAPI\n, we are referring to an \nApi\n class definition.\n\nAll functionality on the bus is defined using APIs.\n\n\nFor example, consider an API for support tickets within a company's \nhelp desk:\n\n\nclass\n \nTicketApi\n(\nApi\n):\n\n    \nticket_created\n \n=\n \nEvent\n(\nparameters\n=\n(\n'id'\n,\n \n'sender'\n,\n \n'subject'\n,\n \n'body'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'help_desk.ticket'\n\n\n    \ndef\n \nget\n(\nself\n,\n \nid\n):\n\n        \nreturn\n \nget_ticket_from_db\n(\npk\n=\nid\n)\n\n\n\n\n\nThis API defines an event, a procedure, and the name used to address the API\non the bus. The help desk service could define multiple additional APIs as needed\n(perhaps for listing help desk staff or retrieving reports).\n\n\nAPI registration & authoritative/non-authoritative APIs\n\u00b6\n\n\nAn API can be registered with your service's bus client as follows:\n\n\nimport\n \nlightbus\n\n\nfrom\n \nmy_apis\n \nimport\n \nHelpDeskApi\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Register the API with your service's client\n\n\nbus\n.\nclient\n.\nregister_api\n(\nHelpDeskApi\n())\n\n\n\n\n\nRegistering an API will:\n\n\n\n\nAllow you to \nfire events\n on the API using the service's client\n\n\nCause the lightbus worker for this service (i.e. \nlightbus run\n) \n   to \nrespond to remote procedure calls\n on the registered API\n\n\n\n\nWe say that a service which registers an API is \nauthoritative\n for that API.\nServices which do not register a given API are \nnon-authoritative\n for the API.\n\nBoth authoritative and non-authoritative services can listen for events on any API and \ncall remote procedures on any API.\n\n\nFor example, a separate online store service could not fire the \nhelp_desk.ticket_created\n\nevent on the API we defined above. Nor would you reasonably expect the online store to \nservices remote procedure calls for \nhelp_desk.ticket_created()\n.\n\n\nWhy?\n\u00b6\n\n\nPreventing the online store service from responding to \nremote procedure calls\n for the \nhelp desk service makes sense. There is no reason the online store should have any \nawareness of the help desk, so you would not expect it to respond to remote \nprocedure calls regarding tickets. \n\n\nTherefore, the logic for allowing only authoritative services to respond to remote procedure calls\nis hopefully compelling.\n\n\nThe case for limiting event firing to authoritative services is one of architecture, maintainability,\nand consistency:\n\n\n\n\nAllowing any event to be fired by any service within your organisation could quickly \n  lead to spiraling complexity.\n\n\nThe authoritative service will always have sufficient information to guarantee basic validity of an \n  emitted message (for example, the event exists, required parameters are present etc). As a result errors \n  can be caught earlier, rather than allowing them to propagate onto the bus and potentially impact distant\n  services.\n\n\n\n\nWe welcome discussion on this topic, \nopen a GitHub issue\n if you would like to discuss this further.",
            "title": "APIs"
        },
        {
            "location": "/explanation/apis/#apis",
            "text": "When we refer to an  API , we are referring to an  Api  class definition. All functionality on the bus is defined using APIs.  For example, consider an API for support tickets within a company's \nhelp desk:  class   TicketApi ( Api ): \n     ticket_created   =   Event ( parameters = ( 'id' ,   'sender' ,   'subject' ,   'body' )) \n\n     class   Meta : \n         name   =   'help_desk.ticket' \n\n     def   get ( self ,   id ): \n         return   get_ticket_from_db ( pk = id )   This API defines an event, a procedure, and the name used to address the API\non the bus. The help desk service could define multiple additional APIs as needed\n(perhaps for listing help desk staff or retrieving reports).",
            "title": "APIs"
        },
        {
            "location": "/explanation/apis/#api-registration-authoritativenon-authoritative-apis",
            "text": "An API can be registered with your service's bus client as follows:  import   lightbus  from   my_apis   import   HelpDeskApi  bus   =   lightbus . create ()  # Register the API with your service's client  bus . client . register_api ( HelpDeskApi ())   Registering an API will:   Allow you to  fire events  on the API using the service's client  Cause the lightbus worker for this service (i.e.  lightbus run ) \n   to  respond to remote procedure calls  on the registered API   We say that a service which registers an API is  authoritative  for that API.\nServices which do not register a given API are  non-authoritative  for the API. Both authoritative and non-authoritative services can listen for events on any API and \ncall remote procedures on any API.  For example, a separate online store service could not fire the  help_desk.ticket_created \nevent on the API we defined above. Nor would you reasonably expect the online store to \nservices remote procedure calls for  help_desk.ticket_created() .",
            "title": "API registration &amp; authoritative/non-authoritative APIs"
        },
        {
            "location": "/explanation/apis/#why",
            "text": "Preventing the online store service from responding to  remote procedure calls  for the \nhelp desk service makes sense. There is no reason the online store should have any \nawareness of the help desk, so you would not expect it to respond to remote \nprocedure calls regarding tickets.   Therefore, the logic for allowing only authoritative services to respond to remote procedure calls\nis hopefully compelling.  The case for limiting event firing to authoritative services is one of architecture, maintainability,\nand consistency:   Allowing any event to be fired by any service within your organisation could quickly \n  lead to spiraling complexity.  The authoritative service will always have sufficient information to guarantee basic validity of an \n  emitted message (for example, the event exists, required parameters are present etc). As a result errors \n  can be caught earlier, rather than allowing them to propagate onto the bus and potentially impact distant\n  services.   We welcome discussion on this topic,  open a GitHub issue  if you would like to discuss this further.",
            "title": "Why?"
        },
        {
            "location": "/explanation/rpcs/",
            "text": "Remote Procedure Calls (RPCs)\n\u00b6\n\n\nA remote procedure call is where you call a procedure available on the bus.\nThe sequence of events is:\n\n\n\n\nYou call the RPC, \nbus.auth.check_password()\n\n\nAn autoratitive process for the \nauth\n API handles the request and sends the response.\n\n\nYou receive the result\n\n\n\n\n\n\nRemote Procedure Calls are useful when:\n\n\n\n\nYou require information from a service \n1\n\n\nYou wish to wait until a remote procedure has completed an action\n\n\n\n\nYou can perform an RPC as follows:\n\n\nsupport_case\n \n=\n \nbus\n.\nsupport\n.\ncase\n.\nget\n(\npk\n=\n123\n)\n\n\n\n\n\nRPCs do not provide a \nfire and forget\n mode of operation.\nConsider using \nevents\n if you need this feature.\n\n\nAt most once semantics\n\u00b6\n\n\nRemote procedure calls will be processed at most once. In some situations the call will \nnever be processed, in which case the client will raise a \nLigutbusTimeout\n exception. \n\n\nConsiderations\n\u00b6\n\n\nWhether to use RPCs or events for communication will depend upon your project's particular needs.\nSome considerations are:\n\n\n\n\nRPCs are \nconceptually simple\n. You call a procedure and wait for a response. You do not need to \n  store any state locally, you can simply request data on demand (performance considerations aside).\n\n\nRPCs can be \nfragile\n. Any errors in the remote service will propagate to the client's service.\n  You should handle these if possible.\n\n\nTheir use within a codebase may be non-obvious, leading to poor performance.\n  Lightbus tries to alleviate this somewhat by using the\n  \nbus.api.method()\n calling format, making it clear that this is a\n  bus-based operation.\n\n\n\n\n\n\n\n\n\n\n\n\nThis is also achievable with \nevents\n. However you will need to listen\n  for the events and likely store the data locally. See the \nevents\n\n  section for further discussion.\u00a0\n\u21a9",
            "title": "Remote prcedure calls"
        },
        {
            "location": "/explanation/rpcs/#remote-procedure-calls-rpcs",
            "text": "A remote procedure call is where you call a procedure available on the bus.\nThe sequence of events is:   You call the RPC,  bus.auth.check_password()  An autoratitive process for the  auth  API handles the request and sends the response.  You receive the result    Remote Procedure Calls are useful when:   You require information from a service  1  You wish to wait until a remote procedure has completed an action   You can perform an RPC as follows:  support_case   =   bus . support . case . get ( pk = 123 )   RPCs do not provide a  fire and forget  mode of operation.\nConsider using  events  if you need this feature.",
            "title": "Remote Procedure Calls (RPCs)"
        },
        {
            "location": "/explanation/rpcs/#at-most-once-semantics",
            "text": "Remote procedure calls will be processed at most once. In some situations the call will \nnever be processed, in which case the client will raise a  LigutbusTimeout  exception.",
            "title": "At most once semantics"
        },
        {
            "location": "/explanation/rpcs/#considerations",
            "text": "Whether to use RPCs or events for communication will depend upon your project's particular needs.\nSome considerations are:   RPCs are  conceptually simple . You call a procedure and wait for a response. You do not need to \n  store any state locally, you can simply request data on demand (performance considerations aside).  RPCs can be  fragile . Any errors in the remote service will propagate to the client's service.\n  You should handle these if possible.  Their use within a codebase may be non-obvious, leading to poor performance.\n  Lightbus tries to alleviate this somewhat by using the\n   bus.api.method()  calling format, making it clear that this is a\n  bus-based operation.       This is also achievable with  events . However you will need to listen\n  for the events and likely store the data locally. See the  events \n  section for further discussion.\u00a0 \u21a9",
            "title": "Considerations"
        },
        {
            "location": "/explanation/events/",
            "text": "Events\n\u00b6\n\n\nFiring an event will place the event onto the bus and return immediately. No information\nis provided as to whether the event was processed, or indeed of it was received by any\nother service at all. No return value is provided when firing an event.\n\n\nThis is useful when:\n\n\n\n\nYou wish to allow non-\nauthoritative\n services to receive information without needing to concern yourself\n   with their implementation\n\n\nYou wish the authoritative service to perform a known task in the background\n\n\n\n\nThe \nquickstart\n provides an example of the latter case.\n\n\nAt-least-once semantics\n\u00b6\n\n\nDelivering a message exactly once is Very Difficult.\nDelivering a message at-most-once, or at-least-once is\nmuch more practical. \nLightbus therefore provides\nat-least-once delivery for events\n.\n\n\nAs a result you can assume your event listeners will\nalways receive an event, but sometimes a listener may\nbe called multiple times for the same event.\n\n\nYou can handle this by ensuring your event listeners\nare idempotent. That is, implement your event listeners in such a\nway that it doesn't matter how many times they are executed.\n\n\nSee \nhow to write idempotent event handlers\n.\n\n\nService names & listener names\n\u00b6\n\n\nAn event will be delivered once to each \nconsumer group\n. A consumer\ngroup is identified by a name in the form:\n\n\n# Consumer group naming format\n{service_name}-{listener_name}\n\n\n\n\n\nYour \nservice name\n is specified in your \nservice-level configuration\n.\nYour \nlistener name\n is setup when you create your event listener (see below).\n\n\nFor example, this \nbus\n module sets up two listeners. Each listener is\ngiven a \nlistener_name\n, thereby ensuring each listener receives a\ncopy of every \ncompetitor_prices.changed\n event.\n\n\nfrom\n \nmy_handlers\n \nimport\n \nsend_price_alerts\n,\n \nupdate_db\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n(\n\n    \nservice_name\n=\n'price-monitor'\n,\n\n\n)\n\n\n\n# Consumer group name: price-monitor-send-price-alerts\n\n\nbus\n.\ncompetitor_prices\n.\nchanged\n.\nlisten\n(\n\n    \nsend_price_alerts\n,\n\n    \nlistener_name\n=\n\"send_price_alerts\"\n,\n\n\n)\n\n\n\n# Consumer group name: price-monitor-update-db\n\n\nbus\n.\ncompetitor_prices\n.\nchanged\n.\nlisten\n(\n\n    \nupdate_db\n,\n\n    \nlistener_name\n=\n\"update_db\"\n,\n\n\n)\n\n\n\n\n\n\n\nImportant\n\n\nFailure to specify \nlistener_name\n in the above example will\nresult in each message going to \neither\n one listener or the other,\nbut never to both. This is almost certainly not what you want.\n\n\n\n\nProcess names\n\u00b6\n\n\nYour \nservice-level configuration\n also specifies a \nprocess name\n.\nThis is less critical than the service name & listener name pairing\ndescribed above, but still serves an important function.\n\n\nThe \nprocess name\n is used to track which process within a consumer group\nis dealing with a given event.\n\n\nThis is primarily useful when a service runs multiple Lightbus\nprocesses, normally as a result of scaling or reliability requirements.\nThe purpose of a \nprocess name\n is twofold:\n\n\n\n\nEach process has a per-determined length of time to handle and\n   acknowledge a given event. If this time is exceeded then\n   failure will be assumed, and the event may be picked up by another process.\n\n\nWhen a Lightbus process starts up it will check for any\n   outstanding events reserved for its process name. In which case it\n   will process these messages first. This can happen if the process was\n   killed prior to acknowledging messages it was processing.\n\n\n\n\nProviding there is no timeout, \nan event will only be delivered\nto one process per listener within a service\n.\n\n\nThe default process name is a random 4 character string. If left unchanged,\nthen clause 2 (above) will never be triggered (as a process name will not\npersist between process restarts). Any outstanding messages\nwill always have to wait for the timeout period to expire, at which point\nthe will be picked up by another process.\n\n\nConsiderations\n\u00b6\n\n\n\n\nEvents are more complex, you may need maintain state as events are received. \n  The source-of-truth regarding stored state may no longer be clear. Enforcing \n  consistency can become difficult.\n\n\nEvents are more robust. Your service will be able to fire events as long as the bus \n  client can connect. Likewise, you service can listen for events until the cows come home.\n  Incoming events may be delayed by problems in other services, but each service should \n  be isolated from those problems.\n\n\n\n\nConcepts such as Domain Driven Design and Event Sourcing can help to tackle some \nof these problems.\n\n\nBest practices\n\u00b6\n\n\nYou may find some of these best practices & suggestions useful. Just \nremember that there can be exceptions to every rule.\n\n\n\n\nNote\n\n\nSee \narchitecture tips\n for further details.\n\n\n\n\nEvent naming\n\u00b6\n\n\n\n\nName events using the past tense. Use \npage_viewed\n, not \npage_view\n. \n  Use \nitem_created\n, not \ncreate_item\n.\n\n\nWhere relevant, consider using domain-based naming rather than technical names.\n  For example, use \norder_placed\n, not \norder_created\n. Use \n  \nparcel_delivered\n, not \nparcel_updated\n.\n\n\n\n\nParameter values\n\u00b6\n\n\n\n\nConsistent meaning over time (not 'tomorrow', or '6 days ago')\n\n\nChop up your relations (aggregates in DDD)",
            "title": "Events"
        },
        {
            "location": "/explanation/events/#events",
            "text": "Firing an event will place the event onto the bus and return immediately. No information\nis provided as to whether the event was processed, or indeed of it was received by any\nother service at all. No return value is provided when firing an event.  This is useful when:   You wish to allow non- authoritative  services to receive information without needing to concern yourself\n   with their implementation  You wish the authoritative service to perform a known task in the background   The  quickstart  provides an example of the latter case.",
            "title": "Events"
        },
        {
            "location": "/explanation/events/#at-least-once-semantics",
            "text": "Delivering a message exactly once is Very Difficult.\nDelivering a message at-most-once, or at-least-once is\nmuch more practical.  Lightbus therefore provides\nat-least-once delivery for events .  As a result you can assume your event listeners will\nalways receive an event, but sometimes a listener may\nbe called multiple times for the same event.  You can handle this by ensuring your event listeners\nare idempotent. That is, implement your event listeners in such a\nway that it doesn't matter how many times they are executed.  See  how to write idempotent event handlers .",
            "title": "At-least-once semantics"
        },
        {
            "location": "/explanation/events/#service-names-listener-names",
            "text": "An event will be delivered once to each  consumer group . A consumer\ngroup is identified by a name in the form:  # Consumer group naming format\n{service_name}-{listener_name}  Your  service name  is specified in your  service-level configuration .\nYour  listener name  is setup when you create your event listener (see below).  For example, this  bus  module sets up two listeners. Each listener is\ngiven a  listener_name , thereby ensuring each listener receives a\ncopy of every  competitor_prices.changed  event.  from   my_handlers   import   send_price_alerts ,   update_db  bus   =   lightbus . create ( \n     service_name = 'price-monitor' ,  )  # Consumer group name: price-monitor-send-price-alerts  bus . competitor_prices . changed . listen ( \n     send_price_alerts , \n     listener_name = \"send_price_alerts\" ,  )  # Consumer group name: price-monitor-update-db  bus . competitor_prices . changed . listen ( \n     update_db , \n     listener_name = \"update_db\" ,  )    Important  Failure to specify  listener_name  in the above example will\nresult in each message going to  either  one listener or the other,\nbut never to both. This is almost certainly not what you want.",
            "title": "Service names &amp; listener names"
        },
        {
            "location": "/explanation/events/#process-names",
            "text": "Your  service-level configuration  also specifies a  process name .\nThis is less critical than the service name & listener name pairing\ndescribed above, but still serves an important function.  The  process name  is used to track which process within a consumer group\nis dealing with a given event.  This is primarily useful when a service runs multiple Lightbus\nprocesses, normally as a result of scaling or reliability requirements.\nThe purpose of a  process name  is twofold:   Each process has a per-determined length of time to handle and\n   acknowledge a given event. If this time is exceeded then\n   failure will be assumed, and the event may be picked up by another process.  When a Lightbus process starts up it will check for any\n   outstanding events reserved for its process name. In which case it\n   will process these messages first. This can happen if the process was\n   killed prior to acknowledging messages it was processing.   Providing there is no timeout,  an event will only be delivered\nto one process per listener within a service .  The default process name is a random 4 character string. If left unchanged,\nthen clause 2 (above) will never be triggered (as a process name will not\npersist between process restarts). Any outstanding messages\nwill always have to wait for the timeout period to expire, at which point\nthe will be picked up by another process.",
            "title": "Process names"
        },
        {
            "location": "/explanation/events/#considerations",
            "text": "Events are more complex, you may need maintain state as events are received. \n  The source-of-truth regarding stored state may no longer be clear. Enforcing \n  consistency can become difficult.  Events are more robust. Your service will be able to fire events as long as the bus \n  client can connect. Likewise, you service can listen for events until the cows come home.\n  Incoming events may be delayed by problems in other services, but each service should \n  be isolated from those problems.   Concepts such as Domain Driven Design and Event Sourcing can help to tackle some \nof these problems.",
            "title": "Considerations"
        },
        {
            "location": "/explanation/events/#best-practices",
            "text": "You may find some of these best practices & suggestions useful. Just \nremember that there can be exceptions to every rule.   Note  See  architecture tips  for further details.",
            "title": "Best practices"
        },
        {
            "location": "/explanation/events/#event-naming",
            "text": "Name events using the past tense. Use  page_viewed , not  page_view . \n  Use  item_created , not  create_item .  Where relevant, consider using domain-based naming rather than technical names.\n  For example, use  order_placed , not  order_created . Use \n   parcel_delivered , not  parcel_updated .",
            "title": "Event naming"
        },
        {
            "location": "/explanation/events/#parameter-values",
            "text": "Consistent meaning over time (not 'tomorrow', or '6 days ago')  Chop up your relations (aggregates in DDD)",
            "title": "Parameter values"
        },
        {
            "location": "/explanation/marshelling/",
            "text": "Lightbus has four stages of data marshalling:\n\n\n\n\nEncode / Decode\n\n\nSerialize / Deserialize\n\n\nValidation\n\n\nDeform / Cast\n\n\n\n\nInbound flow\n\u00b6\n\n\nMessages arriving from the bus go through the following stages\nin order to prepare the data for use:\n\n\n\n\nDecode:\n Decode the incoming data (JSON decoding by default)\n\n\nDeserialise:\n Convert decoded data into a \nMessage\n object\n\n\nValidate:\n Validate the incoming message against the JSON schema\n   available on the bus.\n\n\nCast:\n Best effort casting of parameters/results based on\n   the locally available type hinting\n   (\ndisable with \ncast_values\n)).\n\n\n\n\nOutbound flow\n\u00b6\n\n\nThis is the reverse of the inbound flow. Messages being\nsent will go through the following process in order to\nprepare the data for transmission on bus:\n\n\n\n\nDeform:\n Lightbus handles \nNamedTuples\n, \ndataclasses\n\n   and \nother classes\n by converting\n   them into dictionaries. Other common types such as\n   datetimes, Decimals etc are converted into strings.\n   Internally this is referred to as the \ndeform\n process and is\n   the inverse of the \ncast\n process.\n\n\nValidate:\n Validate the outgoing message against the JSON schema\n   available on the bus.\n\n\nSerialize:\n Structures the data in a way suitable for the\n  transport.\n\n\nEncode:\n Converts the data to a form suitable for transmission.\n  This typically means stringifying it, for which lightbus\n  uses JSON encoding by default.\n\n\n\n\nAbout casting\n\u00b6\n\n\nCasting is separate from validation, although both rely on type hints.\nWhereas validation uses a shared\nbus-wide schema to check data validity, casting uses type hints\navailable in the \nlocal codebase\n to marshall event and RPC parameters\ninto a format useful to the service's developer.",
            "title": "Marshelling"
        },
        {
            "location": "/explanation/marshelling/#inbound-flow",
            "text": "Messages arriving from the bus go through the following stages\nin order to prepare the data for use:   Decode:  Decode the incoming data (JSON decoding by default)  Deserialise:  Convert decoded data into a  Message  object  Validate:  Validate the incoming message against the JSON schema\n   available on the bus.  Cast:  Best effort casting of parameters/results based on\n   the locally available type hinting\n   ( disable with  cast_values )).",
            "title": "Inbound flow"
        },
        {
            "location": "/explanation/marshelling/#outbound-flow",
            "text": "This is the reverse of the inbound flow. Messages being\nsent will go through the following process in order to\nprepare the data for transmission on bus:   Deform:  Lightbus handles  NamedTuples ,  dataclasses \n   and  other classes  by converting\n   them into dictionaries. Other common types such as\n   datetimes, Decimals etc are converted into strings.\n   Internally this is referred to as the  deform  process and is\n   the inverse of the  cast  process.  Validate:  Validate the outgoing message against the JSON schema\n   available on the bus.  Serialize:  Structures the data in a way suitable for the\n  transport.  Encode:  Converts the data to a form suitable for transmission.\n  This typically means stringifying it, for which lightbus\n  uses JSON encoding by default.",
            "title": "Outbound flow"
        },
        {
            "location": "/explanation/marshelling/#about-casting",
            "text": "Casting is separate from validation, although both rely on type hints.\nWhereas validation uses a shared\nbus-wide schema to check data validity, casting uses type hints\navailable in the  local codebase  to marshall event and RPC parameters\ninto a format useful to the service's developer.",
            "title": "About casting"
        },
        {
            "location": "/explanation/transports/",
            "text": "Transports\n\u00b6\n\n\nTransports provide the communications system for Lightbus. There are four types\nof transport:\n\n\n\n\nRPC transports\n \u2013 sends and consumes RPC calls\n\n\nResult transports\n \u2013 sends and receives RPC results\n\n\nEvent transports\n \u2013 sends and consumes events\n\n\nSchema transports\n \u2013 stores and retrieves the \nbus schema\n\n\n\n\nLightbus ships with a Redis-backed implementation of each of these transports.\n\n\nLightbus can be \nconfigured\n to use custom transports either globally,\nor on a per-API level.",
            "title": "Transports"
        },
        {
            "location": "/explanation/transports/#transports",
            "text": "Transports provide the communications system for Lightbus. There are four types\nof transport:   RPC transports  \u2013 sends and consumes RPC calls  Result transports  \u2013 sends and receives RPC results  Event transports  \u2013 sends and consumes events  Schema transports  \u2013 stores and retrieves the  bus schema   Lightbus ships with a Redis-backed implementation of each of these transports.  Lightbus can be  configured  to use custom transports either globally,\nor on a per-API level.",
            "title": "Transports"
        },
        {
            "location": "/explanation/configuration/",
            "text": "",
            "title": "Configuration*"
        },
        {
            "location": "/explanation/schema/",
            "text": "",
            "title": "Schema*"
        },
        {
            "location": "/contributing/",
            "text": "TODO. Contributions welcome!\n\n\nSpin off into internal docs?\n\n\nDevelopment\n\u00b6\n\n\nPut \nasyncio\n into debug mode:\n\n\nPYTHONASYNCIODEBUG=1\n\n\n\n\n\nRunning the tests\n\u00b6\n\n\nFirst you will need to install the testing requirements:\n\n\npip install .[development]\n\n\n\n\n\nYou will also need Redis 5 or above available locally, specify the path\nto the \nredis-server\n command using the \nREDIS_SERVER\n environment\nvariable:\n\n\nREDIS_SERVER=/Users/adam/Projects/redis/src/redis-server\n\n\n\n\n\nNow you can run the tests using:\n\n\npytest\n\n\n\n\n\nNote that you can run subsets of the tests as follows:\n\n\npytest -m unit  # Fast with high coverage\npytest -m integration\npytest -m reliability\n\n\n\n\n\nCommunity\n\u00b6\n\n\nTODO - Own section?\n\n\nQuote regarding Rust:\n\n\n\n\nFor newbs/outsiders looking in, I think a lot of it has to do with a culture of validating people's experiences.\nThat's difficult. If a user complains about it, the natural reaction can easily be to\ngo defensive (\"You're doing it wrong\" or \"we documented that here\"). Rust has successfully\nfostered a culture of approaching it as an opportunity to learn something (\"Why did you not see the documentation\").\n\n\n\n\nWe should do that.\n\n\nEveryone is coming from different cultures with different language skills.\nAssume perceived rudeness is due to different social norms or\npoorer English skills. Perhaps assume the person has 3 children\nrunning around screaming while they filed the bug report. All these\nattributes stack the deck against them contributing, so try to be\nespecially kind, patient, and grateful, even though your\ninitial response may be the opposite.",
            "title": "Contributing*"
        },
        {
            "location": "/contributing/#development",
            "text": "Put  asyncio  into debug mode:  PYTHONASYNCIODEBUG=1",
            "title": "Development"
        },
        {
            "location": "/contributing/#running-the-tests",
            "text": "First you will need to install the testing requirements:  pip install .[development]  You will also need Redis 5 or above available locally, specify the path\nto the  redis-server  command using the  REDIS_SERVER  environment\nvariable:  REDIS_SERVER=/Users/adam/Projects/redis/src/redis-server  Now you can run the tests using:  pytest  Note that you can run subsets of the tests as follows:  pytest -m unit  # Fast with high coverage\npytest -m integration\npytest -m reliability",
            "title": "Running the tests"
        },
        {
            "location": "/contributing/#community",
            "text": "TODO - Own section?  Quote regarding Rust:   For newbs/outsiders looking in, I think a lot of it has to do with a culture of validating people's experiences.\nThat's difficult. If a user complains about it, the natural reaction can easily be to\ngo defensive (\"You're doing it wrong\" or \"we documented that here\"). Rust has successfully\nfostered a culture of approaching it as an opportunity to learn something (\"Why did you not see the documentation\").   We should do that.  Everyone is coming from different cultures with different language skills.\nAssume perceived rudeness is due to different social norms or\npoorer English skills. Perhaps assume the person has 3 children\nrunning around screaming while they filed the bug report. All these\nattributes stack the deck against them contributing, so try to be\nespecially kind, patient, and grateful, even though your\ninitial response may be the opposite.",
            "title": "Community"
        },
        {
            "location": "/explanation/lightbus-vs-celery/",
            "text": "Lightbus vs Celery\n\u00b6\n\n\nLightbus was conceived as a result of using Celery to communicate\nbetween multiple Python services.\n\n\nDifferences in principle\n\u00b6\n\n\nCelery is a task queue:\n\n\n\n\nA task queue is tightly coupled. The dispatching code must know what needs to be done\n\n\nA task queue typically doesn't return results\n\n\n\n\nLightbus is a bus:\n\n\n\n\nA bus provides loose coupling. The dispatching code says what did happen, not what should happen (events)\n\n\nA bus provides bi-directional communication (remote procedure calls)\n\n\n\n\nDifferences in practice\n\u00b6\n\n\nA number of pain points were identified with Celery that Lightbus\naims to address. In particular:\n\n\n\n\nSingle vs multi-\nservice\n \u2013 Celery is targeted as being a task queue for a service, rather than a means for multiple services to interact.\n\n\nConceptual overlap \u2013 The mapping between concepts in Celery and the underlying broker (AMQP at the time) is both unclear and overlapping.\n  Lightbus provides a limited set of well defined concepts to avoid this confusion.\n\n\nNon-sane defaults \u2013 Some Celery settings have non-sane defaults, making setup somewhat perilous at times.\n  Lightbus provides sane defaults for most circumstances, and documentation specifically geared to certain use cases (\nmetrics\n, \nevent sourcing\n)\n\n\nTight coupling (as discussed above) \u2013 Celery tasks define the action to take, not what happened. Lightbus uses events,\n  which describe happened, and listening services decide the action to take.\n\n\nGeneral feeling \u2013 Celery feels large and opaque, debugging issues was challenging. Lightbus aims to feel lightweight, with clear\n  logging and debugging tools.",
            "title": "Lightbus vs Celery"
        },
        {
            "location": "/explanation/lightbus-vs-celery/#lightbus-vs-celery",
            "text": "Lightbus was conceived as a result of using Celery to communicate\nbetween multiple Python services.",
            "title": "Lightbus vs Celery"
        },
        {
            "location": "/explanation/lightbus-vs-celery/#differences-in-principle",
            "text": "Celery is a task queue:   A task queue is tightly coupled. The dispatching code must know what needs to be done  A task queue typically doesn't return results   Lightbus is a bus:   A bus provides loose coupling. The dispatching code says what did happen, not what should happen (events)  A bus provides bi-directional communication (remote procedure calls)",
            "title": "Differences in principle"
        },
        {
            "location": "/explanation/lightbus-vs-celery/#differences-in-practice",
            "text": "A number of pain points were identified with Celery that Lightbus\naims to address. In particular:   Single vs multi- service  \u2013 Celery is targeted as being a task queue for a service, rather than a means for multiple services to interact.  Conceptual overlap \u2013 The mapping between concepts in Celery and the underlying broker (AMQP at the time) is both unclear and overlapping.\n  Lightbus provides a limited set of well defined concepts to avoid this confusion.  Non-sane defaults \u2013 Some Celery settings have non-sane defaults, making setup somewhat perilous at times.\n  Lightbus provides sane defaults for most circumstances, and documentation specifically geared to certain use cases ( metrics ,  event sourcing )  Tight coupling (as discussed above) \u2013 Celery tasks define the action to take, not what happened. Lightbus uses events,\n  which describe happened, and listening services decide the action to take.  General feeling \u2013 Celery feels large and opaque, debugging issues was challenging. Lightbus aims to feel lightweight, with clear\n  logging and debugging tools.",
            "title": "Differences in practice"
        },
        {
            "location": "/explanation/architecture-tips/",
            "text": "Architecture tips\n\u00b6\n\n\nThese tips draw some core concepts from\nthe [Domain Driven Design] and [CQRS] patterns. I only\nscape the surface of these patterns here, but the ideas covered\nbelow are the ones I found most useful when using Lightbus.\n\n\nThere is a lot more to be said on each point. The intent\nhere is to provide a digestible starting point.\n\n\nUse common data structures\n\u00b6\n\n\nCreate structures which represent the data you wish to transmit.\nBoth [NamedTuples] and [dataclasses] work well for this purpose.\n\n\nFor example:\n\n\nfrom\n \ntyping\n \nimport\n \nNamedTuple\n\n\n\nclass\n \nCustomer\n(\nNamedTuple\n):\n\n    \nname\n:\n \nstr\n\n    \nemail\n:\n \nstr\n\n    \nage\n:\n \nint\n\n\n\n\n\nYou can then take advantage of Lightbus' schema checking a data casting:\n\n\nimport\n \nlightbus\n\n\n\nclass\n \nCustomerApi\n(\nlightbus\n.\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n\"customer\"\n\n\n    \ndef\n \ncreate\n(\ncustomer\n:\n \nCustomer\n):\n\n        \n# Lightbus will ensure the incoming data conforms to\n\n        \n# Customer, and will cast the to be a Customer object\n\n        \n...\n\n\n\n\n\nYou would call the \ncustomer.create()\n API as follows:\n\n\nimport\n \nlightbus\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\nbus\n.\ncustomer\n.\ncreate\n(\n\n    \ncustomer\n=\nCustomer\n(\nname\n=\n\"Joe\"\n,\n \nemail\n=\n\"joe@gmail.com\"\n,\n \nage\n=\n54\n)\n\n\n)\n\n\n\n\n\nThis provides a standard way of communicating shared concepts across\nyour services.\n\n\n\n\nNote\n\n\nYou can still send and receive events even if you do\nnot have the data strucuture available. To send you can simply\nuse a dictionary:\n\n\nbus\n.\ncustomer\n.\ncreate\n(\n\n    \ncustomer\n=\n{\n\"name\"\n:\n \n\"Joe\"\n,\n \n\"email\"\n:\n \n\"joe@gmail.com\"\n,\n \n\"age\"\n:\n \n54\n}\n\n\n)\n\n\n\n\n\nLikewise, an RPC or event listener without type hints will simply\nreceive a dictionary.\n\n\n\n\nDecide on boundaries\n\u00b6\n\n\nYour services will likely use an assortment of entities. It is common\nfor these to map to database tables or [ORM] classes. For example,\nyou may have \nCustomer\n, \nAddress\n, \nOrder\n, and \nOrderLine\n  entities (and probably\nmany more). You will need to pass these between your services,\nbut how should you structure them in order to do so? Do pass them\nindividually, or combine them into a hierarchy? Do you sometimes\nomit some fields for brevity, or not?\n\n\nTake the following events for example:\n\n\n\n\ncustomer.signup(customer)\n \u2013 Does the \ncustomer\n object include the address(es)?\n\n\norder.shipped(order)\n \u2013 Does the \norder\n object contain each line item?\n\n\norder.line_item_deleted(order, line_item)\n \u2013 Do we need to pass \nline_item\n here, or should the line items be included within \norder\n?\n\n\n\n\nThis is a simple example with only four entities. In a real-world\nsystem it is very easy to end up passing around data in\nforms which become increasingly bloated, inconsistent, and complex.\n\n\nYou can mitigate this by grouping your entities together in a way that\nmakes logical sense for your situation\n. These are your \naggregates\n.\nDecide on these aggregates in advance, and stick to it\n\n\nFor example, we may group the \nCustomer\n, \nAddress\n, \nOrder\n, and \nOrderLine\n\nentities as follows:\n\n\n\n\nA \nCustomer\n aggregate. Each \nCustomer\n contains an \naddress\n field, which is an \nAddress\n entity.\n\n\nAn \nOrder\n aggregate. Each \nOrder\n contains a \nline_items\n field, which is a list of \nOrderLine\n entities.\n\n\n\n\nYou should only ever pass around the top level aggregates.\n\n\nAdditionally:\n\n\n\n\nIdentify aggregates with UUIDs\n\n\nDo not enforce foreign keys between aggregates. Your application code\n  will need to deal with inconsistencies gracefully.\n\n\nProbably still still a good idea to use sequential integer primary keys in your RDBMS\n\n\nDo \nnot\n share database-level sequential integer primary keys\n\n\n\n\nWrites are special\n\u00b6\n\n\nWrites are inherently different to reads in a distributed system.\nReading data is generally straightforward, whereas data modifications\nneed to be propagated to all concerned services.\n\n\nReading data\n looks broadly like this:\n\n\n\n\nRead data from storage (disk, ORM, memory etc)\n\n\nPerhaps transform the data\n\n\nDisplay the data, or send it somewhere\n\n\n\n\nAn \ninitial attempt at writing data\n may look like this:\n\n\n\n\nWrite the data locally\n\n\nBroadcast the change (Lightbus event or RPC)\n\n\nOther services receive & apply the change\n\n\n\n\nTODO: Pros/cons.\n\n\nA more \nCQRS-based approach to writing data\n looks like this:\n\n\n\n\nBroadcast the change (Lightbus event)\n\n\nServices (including the broadcasting service) receive & apply the change\n\n\n\n\nTODO: Pros/cons.\n\n\nUse a mono-repository\n\u00b6\n\n\n\n\nSharing data structures\n\n\nAtomic commits across services\n\n\nEasier project wide changes",
            "title": "Architecture tips"
        },
        {
            "location": "/explanation/architecture-tips/#architecture-tips",
            "text": "These tips draw some core concepts from\nthe [Domain Driven Design] and [CQRS] patterns. I only\nscape the surface of these patterns here, but the ideas covered\nbelow are the ones I found most useful when using Lightbus.  There is a lot more to be said on each point. The intent\nhere is to provide a digestible starting point.",
            "title": "Architecture tips"
        },
        {
            "location": "/explanation/architecture-tips/#use-common-data-structures",
            "text": "Create structures which represent the data you wish to transmit.\nBoth [NamedTuples] and [dataclasses] work well for this purpose.  For example:  from   typing   import   NamedTuple  class   Customer ( NamedTuple ): \n     name :   str \n     email :   str \n     age :   int   You can then take advantage of Lightbus' schema checking a data casting:  import   lightbus  class   CustomerApi ( lightbus . Api ): \n\n     class   Meta : \n         name   =   \"customer\" \n\n     def   create ( customer :   Customer ): \n         # Lightbus will ensure the incoming data conforms to \n         # Customer, and will cast the to be a Customer object \n         ...   You would call the  customer.create()  API as follows:  import   lightbus  bus   =   lightbus . create ()  bus . customer . create ( \n     customer = Customer ( name = \"Joe\" ,   email = \"joe@gmail.com\" ,   age = 54 )  )   This provides a standard way of communicating shared concepts across\nyour services.   Note  You can still send and receive events even if you do\nnot have the data strucuture available. To send you can simply\nuse a dictionary:  bus . customer . create ( \n     customer = { \"name\" :   \"Joe\" ,   \"email\" :   \"joe@gmail.com\" ,   \"age\" :   54 }  )   Likewise, an RPC or event listener without type hints will simply\nreceive a dictionary.",
            "title": "Use common data structures"
        },
        {
            "location": "/explanation/architecture-tips/#decide-on-boundaries",
            "text": "Your services will likely use an assortment of entities. It is common\nfor these to map to database tables or [ORM] classes. For example,\nyou may have  Customer ,  Address ,  Order , and  OrderLine   entities (and probably\nmany more). You will need to pass these between your services,\nbut how should you structure them in order to do so? Do pass them\nindividually, or combine them into a hierarchy? Do you sometimes\nomit some fields for brevity, or not?  Take the following events for example:   customer.signup(customer)  \u2013 Does the  customer  object include the address(es)?  order.shipped(order)  \u2013 Does the  order  object contain each line item?  order.line_item_deleted(order, line_item)  \u2013 Do we need to pass  line_item  here, or should the line items be included within  order ?   This is a simple example with only four entities. In a real-world\nsystem it is very easy to end up passing around data in\nforms which become increasingly bloated, inconsistent, and complex.  You can mitigate this by grouping your entities together in a way that\nmakes logical sense for your situation . These are your  aggregates .\nDecide on these aggregates in advance, and stick to it  For example, we may group the  Customer ,  Address ,  Order , and  OrderLine \nentities as follows:   A  Customer  aggregate. Each  Customer  contains an  address  field, which is an  Address  entity.  An  Order  aggregate. Each  Order  contains a  line_items  field, which is a list of  OrderLine  entities.   You should only ever pass around the top level aggregates.  Additionally:   Identify aggregates with UUIDs  Do not enforce foreign keys between aggregates. Your application code\n  will need to deal with inconsistencies gracefully.  Probably still still a good idea to use sequential integer primary keys in your RDBMS  Do  not  share database-level sequential integer primary keys",
            "title": "Decide on boundaries"
        },
        {
            "location": "/explanation/architecture-tips/#writes-are-special",
            "text": "Writes are inherently different to reads in a distributed system.\nReading data is generally straightforward, whereas data modifications\nneed to be propagated to all concerned services.  Reading data  looks broadly like this:   Read data from storage (disk, ORM, memory etc)  Perhaps transform the data  Display the data, or send it somewhere   An  initial attempt at writing data  may look like this:   Write the data locally  Broadcast the change (Lightbus event or RPC)  Other services receive & apply the change   TODO: Pros/cons.  A more  CQRS-based approach to writing data  looks like this:   Broadcast the change (Lightbus event)  Services (including the broadcasting service) receive & apply the change   TODO: Pros/cons.",
            "title": "Writes are special"
        },
        {
            "location": "/explanation/architecture-tips/#use-a-mono-repository",
            "text": "Sharing data structures  Atomic commits across services  Easier project wide changes",
            "title": "Use a mono-repository"
        },
        {
            "location": "/reference/",
            "text": "Reference overview\n\u00b6\n\n\nThis section provides \ndetailed information regarding the specific\nfeatures of Lightbus\n.\n\n\nA grasp of the \ntutorial\n and \nexplantion\n sections will\nbe useful here.",
            "title": "Overview"
        },
        {
            "location": "/reference/#reference-overview",
            "text": "This section provides  detailed information regarding the specific\nfeatures of Lightbus .  A grasp of the  tutorial  and  explantion  sections will\nbe useful here.",
            "title": "Reference overview"
        },
        {
            "location": "/reference/apis/",
            "text": "APIs specify the functionality available on the bus. To do this you\ndefine API classes within your \nbus.py\n file. You can also define\nyour API elsewhere and import it into your \nbus.py\n file.\n\n\nFor further discussion of APIs \nsee the concepts section\n.\n\n\nAn example API\n\u00b6\n\n\n# An example API. You can define this in your bus.py,\n\n\n# or import into your bus.py file from elsewhere\n\n\n\nclass\n \nSupportCaseApi\n(\nApi\n):\n\n    \n# An event,\n\n    \n# available at bus.support.case.case_created\n\n    \ncase_created\n \n=\n \nEvent\n(\nparameters\n=\n(\n'id'\n,\n \n'sender'\n,\n \n'subject'\n,\n \n'body'\n))\n\n\n    \n# Options for this API\n\n    \nclass\n \nMeta\n:\n\n        \n# API name on the bus\n\n        \nname\n \n=\n \n'support.case'\n\n\n    \n# Will be available as a remote procedure call at\n\n    \n# bus.support.case.get()\n\n    \ndef\n \nget\n(\nself\n,\n \nid\n):\n\n        \nreturn\n \nget_case_from_db\n(\npk\n=\nid\n)\n\n\n\n\n\nA service can define zero or more APIs, and each API can contain\nzero or more events and zero or more procedures.\n\n\nThe \nMeta\n class specifies options regarding the API, with \nname\n being\nthe only required option. The name specifies how the API will be\naccessed on the bus.\n\n\nYou could call an RPC on the above API as follows:\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Call the get_case() RPC.\n\n\ncase\n \n=\n \nbus\n.\nsupport\n.\ncase\n.\nget_case\n(\nid\n=\n123\n)\n\n\n\n\n\nYou can also fire an event on this API:\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n# Fire the case_created event\n\n\nbus\n.\nsupport\n.\ncase\n.\ncase_created\n.\nfire\n(\n\n    \nid\n=\n123\n,\n\n    \nsender\n=\n'Joe'\n,\n\n    \nsubject\n=\n'I need support please!'\n,\n\n    \nbody\n=\n'...'\n,\n\n\n)\n\n\n\n\n\nOptions\n\u00b6\n\n\nname (str)\n\u00b6\n\n\nSpecifies the name of the API. This will determine how the API is addressed\non the bus. See \nnaming\n, below.\n\n\nname\n is a required option.\n\n\nNaming your APIs\n\u00b6\n\n\nAs you can from the \nMeta.name\n option in the example above, API names\ncan contain periods which allow you\nto structure your bus in a suitable form for your situation.\nSome example API naming schemes may look like:\n\n\n# Example API naming schemes for use within Meta.name\n\n\nFormat: \n \n<\nservice\n>\n\n\nExample: \nsupport\n.\nget_case\n()\n\n         \nsupport\n.\nget_activity\n()\n\n\n\n\nFormat: \n \n<\nservice\n>\n.\n<\nobject\n>\n\n\nExample: \nsupport\n.\ncase\n.\nget\n()\n\n         \nsupport\n.\nactivity\n.\nget\n()\n\n\n\n\nFormat: \n \n<\ndeparment\n>\n.\n<\nservice\n>\n.\n<\nobject\n>\n\n\nExample: \nmarketing\n.\nwebsite\n.\nstats\n.\nget\n()\n\n         \nops\n.\nmonitoring\n.\nservers\n.\nget_status\n()\n\n\n\n\n\nOrganising many APIs\n\u00b6\n\n\n\n\nWill lightbus recognise a bus package as well as a bus module?\n  (i.e.\nbus/__init__.py\n?) TODO\n\n\nIt does now",
            "title": "APIs"
        },
        {
            "location": "/reference/apis/#an-example-api",
            "text": "# An example API. You can define this in your bus.py,  # or import into your bus.py file from elsewhere  class   SupportCaseApi ( Api ): \n     # An event, \n     # available at bus.support.case.case_created \n     case_created   =   Event ( parameters = ( 'id' ,   'sender' ,   'subject' ,   'body' )) \n\n     # Options for this API \n     class   Meta : \n         # API name on the bus \n         name   =   'support.case' \n\n     # Will be available as a remote procedure call at \n     # bus.support.case.get() \n     def   get ( self ,   id ): \n         return   get_case_from_db ( pk = id )   A service can define zero or more APIs, and each API can contain\nzero or more events and zero or more procedures.  The  Meta  class specifies options regarding the API, with  name  being\nthe only required option. The name specifies how the API will be\naccessed on the bus.  You could call an RPC on the above API as follows:  bus   =   lightbus . create ()  # Call the get_case() RPC.  case   =   bus . support . case . get_case ( id = 123 )   You can also fire an event on this API:  bus   =   lightbus . create ()  # Fire the case_created event  bus . support . case . case_created . fire ( \n     id = 123 , \n     sender = 'Joe' , \n     subject = 'I need support please!' , \n     body = '...' ,  )",
            "title": "An example API"
        },
        {
            "location": "/reference/apis/#options",
            "text": "",
            "title": "Options"
        },
        {
            "location": "/reference/apis/#name-str",
            "text": "Specifies the name of the API. This will determine how the API is addressed\non the bus. See  naming , below.  name  is a required option.",
            "title": "name (str)"
        },
        {
            "location": "/reference/apis/#naming-your-apis",
            "text": "As you can from the  Meta.name  option in the example above, API names\ncan contain periods which allow you\nto structure your bus in a suitable form for your situation.\nSome example API naming schemes may look like:  # Example API naming schemes for use within Meta.name  Format:    < service >  Example:  support . get_case () \n          support . get_activity ()  Format:    < service > . < object >  Example:  support . case . get () \n          support . activity . get ()  Format:    < deparment > . < service > . < object >  Example:  marketing . website . stats . get () \n          ops . monitoring . servers . get_status ()",
            "title": "Naming your APIs"
        },
        {
            "location": "/reference/apis/#organising-many-apis",
            "text": "Will lightbus recognise a bus package as well as a bus module?\n  (i.e. bus/__init__.py ?) TODO  It does now",
            "title": "Organising many APIs"
        },
        {
            "location": "/reference/rpcs/",
            "text": "Remote procedures calls (RPCs) are defined as methods on your API\nclasses. They are useful when either:\n\n\n\n\nYou require information from a service\n\n\nYou wish to wait until a remote procedure has completed an action\n\n\n\n\nRPCs provide at-most-once delivery semantics.\n If you need\nat-least-once semantics you should consder using events instead.\n\n\nDefinition\n\u00b6\n\n\nAs covered in previous sections, you define RPCs as follows:\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n,\n \npassword\n):\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n    \ndef\n \nreset_password\n(\nself\n,\n \nusername\n):\n\n        \nreset_users_password_somehow\n(\nusername\n)\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n):\n\n        \nreturn\n \nget_user\n(\nusername\n)\n\n\n    \ndef\n \npromote_to_admin\n(\nusername\n):\n\n        \nuser\n \n=\n \nget_user\n(\nusername\n)\n\n        \nuser\n.\nadmin\n \n=\n \nTrue\n\n        \nuser\n.\nsave\n()\n\n\n\n\n\nCalling\n\u00b6\n\n\nRPCs are called simply as follows:\n\n\n# Anywhere in your code\n\n\n\n# Import your project's bus instance\n\n\nfrom\n \nbus\n \nimport\n \nbus\n\n\n\n# Call the RPC\n\n\nis_valid\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\nusername\n=\n\"adam\"\n,\n \npassword\n=\n\"secr3t\"\n)\n\n\n\n\n\nCalling (asynchronously)\n\u00b6\n\n\nYou can also perform the call asynchronously using asyncio:\n\n\n# Anywhere in your code\n\n\n\n# Import your project's bus instance\n\n\nfrom\n \nbus\n \nimport\n \nbus\n\n\n\nis_valid\n \n=\n \nawait\n \nbus\n.\nauth\n.\ncheck_password\n.\ncall_async\n(\n\n    \nusername\n=\n\"adam\"\n,\n\n    \npassword\n=\n\"secr3t\"\n\n\n)\n\n\n\n\n\nType hints\n\u00b6\n\n\nSee the \ntyping reference\n.\n\n\nBest practices\n\u00b6\n\n\nRPC implementation\n\u00b6\n\n\nIt is best to keep your RPCs simple and easy to understand.\nIn anything but the simplest service it will probably be best to\nuse the API definition as a presentational layer which wraps up\nthe business logic located elsewhere.\n\n\nIf you find business logic creeping into your RPC definitions,\nconsider factoring it out and invoking it from the RPC definition.\n\n\nFor smaller services this will be less important, but as functionality\nis shared and used elsewhere within your service you may find it keeps\nyour code more managable.\n\n\nThis also leaves your RPCs definitions free do any API-specific\nlegwork such as data marshalling. For example, converting incoming natural keys\n(e.g. usernames) into the primary keys (i.e. user IDs) which your\nservice's may use internally.\n\n\nArchitecture & coupling\n\u00b6\n\n\nRPCs often represent a tight coupling between your code and the\nservice you are calling. This may be acceptable to you, but it is\nworth being aware of potential pitfalls:\n\n\n\n\nFailures & timeouts may occurr, which should ideally be\n  handled gracefully\n\n\nModifications to the remote RPC may require updates to the\n  code which calls the RPC\n\n\nRPCs incur much greater overhead than regular function calls.\n  Utility functions that use RPCs should therefore make it clear\n  that they will be incurring this overhead (either through\n  naming convention or documentation)\n\n\nThe more services call to for a given action, the less\n  reliable the action will typically be. (i.e. if any service is\n  unavailable the action will potentially fail)\n\n\n\n\nUsing events will provide a different set of trade-offs, and\nultimately you will need to decide on what is right for\nyour particular scenario.\n\n\nParameter values\n\u00b6\n\n\nWhen deciding the values your RPC should receive, consider:\n\n\n\n\nCan this value become out of date? For example, an entire user object\n  could become out of date, whereas a username or user ID would not.\n\n\nPacking and unpacking large data structures is computationally expensive.\n\n\nWill the meaning of the value change over time? For example, the meaning of 'today' or\n  'now' will change, but the meaning of a specific date & time will remain the same.\n\n\n\n\nLimitations\n\u00b6\n\n\nRPCs can only be called with keyword arguments. For example:\n\n\n# Raises an InvalidParameters exception\n\n\nresult\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\n'admin'\n,\n \n'secret'\n)\n  \n# ERROR\n\n\n\n# Success\n\n\nresult\n \n=\n \nbus\n.\nauth\n.\ncheck_password\n(\nusername\n=\n'admin'\n,\n \npassword\n=\n'secret'\n)",
            "title": "Remote prcedure calls"
        },
        {
            "location": "/reference/rpcs/#definition",
            "text": "As covered in previous sections, you define RPCs as follows:  # bus.py  from   lightbus   import   Api  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   username ,   password ): \n         return   username   ==   'admin'   and   password   ==   'secret' \n\n     def   reset_password ( self ,   username ): \n         reset_users_password_somehow ( username ) \n\n     def   get_user ( self ,   username ): \n         return   get_user ( username ) \n\n     def   promote_to_admin ( username ): \n         user   =   get_user ( username ) \n         user . admin   =   True \n         user . save ()",
            "title": "Definition"
        },
        {
            "location": "/reference/rpcs/#calling",
            "text": "RPCs are called simply as follows:  # Anywhere in your code  # Import your project's bus instance  from   bus   import   bus  # Call the RPC  is_valid   =   bus . auth . check_password ( username = \"adam\" ,   password = \"secr3t\" )",
            "title": "Calling"
        },
        {
            "location": "/reference/rpcs/#calling-asynchronously",
            "text": "You can also perform the call asynchronously using asyncio:  # Anywhere in your code  # Import your project's bus instance  from   bus   import   bus  is_valid   =   await   bus . auth . check_password . call_async ( \n     username = \"adam\" , \n     password = \"secr3t\"  )",
            "title": "Calling (asynchronously)"
        },
        {
            "location": "/reference/rpcs/#type-hints",
            "text": "See the  typing reference .",
            "title": "Type hints"
        },
        {
            "location": "/reference/rpcs/#best-practices",
            "text": "",
            "title": "Best practices"
        },
        {
            "location": "/reference/rpcs/#rpc-implementation",
            "text": "It is best to keep your RPCs simple and easy to understand.\nIn anything but the simplest service it will probably be best to\nuse the API definition as a presentational layer which wraps up\nthe business logic located elsewhere.  If you find business logic creeping into your RPC definitions,\nconsider factoring it out and invoking it from the RPC definition.  For smaller services this will be less important, but as functionality\nis shared and used elsewhere within your service you may find it keeps\nyour code more managable.  This also leaves your RPCs definitions free do any API-specific\nlegwork such as data marshalling. For example, converting incoming natural keys\n(e.g. usernames) into the primary keys (i.e. user IDs) which your\nservice's may use internally.",
            "title": "RPC implementation"
        },
        {
            "location": "/reference/rpcs/#architecture-coupling",
            "text": "RPCs often represent a tight coupling between your code and the\nservice you are calling. This may be acceptable to you, but it is\nworth being aware of potential pitfalls:   Failures & timeouts may occurr, which should ideally be\n  handled gracefully  Modifications to the remote RPC may require updates to the\n  code which calls the RPC  RPCs incur much greater overhead than regular function calls.\n  Utility functions that use RPCs should therefore make it clear\n  that they will be incurring this overhead (either through\n  naming convention or documentation)  The more services call to for a given action, the less\n  reliable the action will typically be. (i.e. if any service is\n  unavailable the action will potentially fail)   Using events will provide a different set of trade-offs, and\nultimately you will need to decide on what is right for\nyour particular scenario.",
            "title": "Architecture &amp; coupling"
        },
        {
            "location": "/reference/rpcs/#parameter-values",
            "text": "When deciding the values your RPC should receive, consider:   Can this value become out of date? For example, an entire user object\n  could become out of date, whereas a username or user ID would not.  Packing and unpacking large data structures is computationally expensive.  Will the meaning of the value change over time? For example, the meaning of 'today' or\n  'now' will change, but the meaning of a specific date & time will remain the same.",
            "title": "Parameter values"
        },
        {
            "location": "/reference/rpcs/#limitations",
            "text": "RPCs can only be called with keyword arguments. For example:  # Raises an InvalidParameters exception  result   =   bus . auth . check_password ( 'admin' ,   'secret' )    # ERROR  # Success  result   =   bus . auth . check_password ( username = 'admin' ,   password = 'secret' )",
            "title": "Limitations"
        },
        {
            "location": "/reference/events/",
            "text": "Events are defined as properties on your \nAPI\n classes.\nEvents are useful when:\n\n\n\n\nYou need asynchronous communication between services\n\n\nYou wish to loosely-couple your services\n\n\nYou need a service to perform a task in the background\n\n\n\n\nSee \nevent considerations\n in the explanations section for further\ndiscussion.\n\n\nEvents provide at-least-once delivery semantics.\n Given this,\nyour event handlers should be \nidempotent\n.\n\n\nDefining events\n\u00b6\n\n\nYou can define events using the \nlightbus.Event\n class. For example,\nyou could define the following bus.py in your authenication service:\n\n\n# auth_service/bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n,\n \nEvent\n\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n    \nuser_created\n \n=\n \nEvent\n(\nparameters\n=\n(\n'username'\n,\n \n'email'\n))\n\n    \nuser_updated\n \n=\n \nEvent\n(\nparameters\n=\n(\n'username'\n,\n \n'new_email'\n))\n\n    \nuser_deleted\n \n=\n \nEvent\n(\nparameters\n=\n(\n'username'\n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n\n\n\nFiring events\n\u00b6\n\n\nYou can fire events as follows:\n\n\n# Anywhere in your code\n\n\n\n# Import your project's bus instance\n\n\nfrom\n \nbus\n \nimport\n \nbus\n\n\n\nbus\n.\nauth\n.\nuser_created\n.\nfire\n(\nusername\n=\n'adam'\n,\n \npassword\n=\n'adam@example.com'\n)\n\n\n\n\n\nFiring events (asynchronously)\n\u00b6\n\n\nYou can also fire events asynchronously using asyncio:\n\n\n# Anywhere in your code\n\n\n\n# Import your project's bus instance\n\n\nfrom\n \nbus\n \nimport\n \nbus\n\n\n\nawait\n \nbus\n.\nauth\n.\nuser_created\n.\nfire_async\n(\n\n    \nusername\n=\n'adam'\n,\n\n    \npassword\n=\n'adam@example.com'\n\n\n)\n\n\n\n\n\nListening for events\n\u00b6\n\n\nListening for events is typically a long-running background\nactivity, and is therefore dealt with by the \nlightbus run\n\ncommand.\n\n\nYou can setup these listeners in another services' \nbus\n module\nas follows:\n\n\n# other_service/bus.py\n\n\nimport\n \nlightbus\n\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\nuser_db\n \n=\n \n{}\n\n\n\n\ndef\n \nhandle_created\n(\nusername\n,\n \nemail\n):\n\n    \nuser_db\n[\nusername\n]\n \n=\n \nemail\n\n    \nprint\n(\nuser_db\n)\n\n\n\n\ndef\n \nhandle_updated\n(\nusername\n,\n \nemail\n):\n\n    \nuser_db\n[\nusername\n]\n \n=\n \nemail\n\n    \nprint\n(\nuser_db\n)\n\n\n\n\ndef\n \nhandle_deleted\n(\nusername\n,\n \nemail\n):\n\n    \nuser_db\n.\npop\n(\nusername\n)\n\n    \nprint\n(\nuser_db\n)\n\n\n\n\n@bus\n.\nclient\n.\non_start\n()\n\n\ndef\n \non_start\n():\n\n    \n# Bus client has started up, so register our listeners\n\n\n    \nbus\n.\nauth\n.\nuser_created\n.\nlisten\n(\n\n        \nhandle_created\n,\n\n        \nlistener_name\n=\n\"user_created\"\n\n    \n)\n\n    \nbus\n.\nauth\n.\nuser_updated\n.\nlisten\n(\n\n        \nhandle_updated\n,\n\n        \nlistener_name\n=\n\"user_updated\"\n\n    \n)\n\n    \nbus\n.\nauth\n.\nuser_deleted\n.\nlisten\n(\n\n        \nhandle_deleted\n,\n\n        \nlistener_name\n=\n\"user_deleted\"\n\n    \n)\n\n\n\n\n\nSpecifying \nlistener_name\n for each listener ensures each\nlistener will receive its own copy of the \nauth.user_deleted\n event.\nSee the \nevents explanation page\n for further discussion.\n\n\nListening for events (asynchronously)\n\u00b6\n\n\nEvent listener setup shown above should normally happen very quickly,\nhowever the process does still require some input/output.\n\n\nYou can therefore modify the above example to setup an event\nlistener asynchronously using the \nlist_async()\n method:\n\n\n# ...snipped from above example\n\n\n\n# Note that our startup handler below is defined as async\n\n\n@bus\n.\nclient\n.\non_start\n()\n\n\nasync\n \ndef\n \non_start\n():\n\n\n    \n# We await the listen_async() method\n\n    \nawait\n \nbus\n.\nauth\n.\nuser_created\n.\nlisten_async\n(\n\n        \nhandle_created\n,\n\n        \nlistener_name\n=\n\"user_created\"\n\n    \n)\n\n\n\n\n\nType hints\n\u00b6\n\n\nSee the \ntyping reference\n.",
            "title": "Events"
        },
        {
            "location": "/reference/events/#defining-events",
            "text": "You can define events using the  lightbus.Event  class. For example,\nyou could define the following bus.py in your authenication service:  # auth_service/bus.py  from   lightbus   import   Api ,   Event  class   AuthApi ( Api ): \n     user_created   =   Event ( parameters = ( 'username' ,   'email' )) \n     user_updated   =   Event ( parameters = ( 'username' ,   'new_email' )) \n     user_deleted   =   Event ( parameters = ( 'username' )) \n\n     class   Meta : \n         name   =   'auth'",
            "title": "Defining events"
        },
        {
            "location": "/reference/events/#firing-events",
            "text": "You can fire events as follows:  # Anywhere in your code  # Import your project's bus instance  from   bus   import   bus  bus . auth . user_created . fire ( username = 'adam' ,   password = 'adam@example.com' )",
            "title": "Firing events"
        },
        {
            "location": "/reference/events/#firing-events-asynchronously",
            "text": "You can also fire events asynchronously using asyncio:  # Anywhere in your code  # Import your project's bus instance  from   bus   import   bus  await   bus . auth . user_created . fire_async ( \n     username = 'adam' , \n     password = 'adam@example.com'  )",
            "title": "Firing events (asynchronously)"
        },
        {
            "location": "/reference/events/#listening-for-events",
            "text": "Listening for events is typically a long-running background\nactivity, and is therefore dealt with by the  lightbus run \ncommand.  You can setup these listeners in another services'  bus  module\nas follows:  # other_service/bus.py  import   lightbus  bus   =   lightbus . create ()  user_db   =   {}  def   handle_created ( username ,   email ): \n     user_db [ username ]   =   email \n     print ( user_db )  def   handle_updated ( username ,   email ): \n     user_db [ username ]   =   email \n     print ( user_db )  def   handle_deleted ( username ,   email ): \n     user_db . pop ( username ) \n     print ( user_db )  @bus . client . on_start ()  def   on_start (): \n     # Bus client has started up, so register our listeners \n\n     bus . auth . user_created . listen ( \n         handle_created , \n         listener_name = \"user_created\" \n     ) \n     bus . auth . user_updated . listen ( \n         handle_updated , \n         listener_name = \"user_updated\" \n     ) \n     bus . auth . user_deleted . listen ( \n         handle_deleted , \n         listener_name = \"user_deleted\" \n     )   Specifying  listener_name  for each listener ensures each\nlistener will receive its own copy of the  auth.user_deleted  event.\nSee the  events explanation page  for further discussion.",
            "title": "Listening for events"
        },
        {
            "location": "/reference/events/#listening-for-events-asynchronously",
            "text": "Event listener setup shown above should normally happen very quickly,\nhowever the process does still require some input/output.  You can therefore modify the above example to setup an event\nlistener asynchronously using the  list_async()  method:  # ...snipped from above example  # Note that our startup handler below is defined as async  @bus . client . on_start ()  async   def   on_start (): \n\n     # We await the listen_async() method \n     await   bus . auth . user_created . listen_async ( \n         handle_created , \n         listener_name = \"user_created\" \n     )",
            "title": "Listening for events (asynchronously)"
        },
        {
            "location": "/reference/events/#type-hints",
            "text": "See the  typing reference .",
            "title": "Type hints"
        },
        {
            "location": "/reference/typing/",
            "text": "Specifying type hints allows Lightbus to validate\ndata types in both incoming and outgoing messages.\n\n\nType hints are used to create your bus' \nschema\n, which is shared\nacross your entire bus.\n\n\nTyping syntax for RPCs\n\u00b6\n\n\nYou can provide typing information for Remote Procedure Calls using\nregular Python type hinting:\n\n\nclass\n \nAuthApi\n(\nlightbus\n.\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n:\n \nstr\n,\n \npassword\n:\n \nstr\n)\n \n->\n \nbool\n:\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n\n\n\nThis will:\n\n\n\n\nEnsure the received \nusername\n parameter is a string\n\n\nEnsure the received \npassword\n parameter is a string\n\n\nEnsure the returned value is a boolean\n\n\n\n\nThis behaviour can be configured via the \nvalidate\n configuration option\n.\n\n\nTyping syntax for events\n\u00b6\n\n\nTyping information for events is different to that for RPCs.\nFirstly, events do not provide return values. Secondly, event\nparameters are specified differently:\n\n\n# auth_service/bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n,\n \nEvent\n,\n \nParameter\n\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n    \n# WITHOUT types\n\n    \nuser_created\n \n=\n \nEvent\n(\nparameters\n=\n(\n'username'\n,\n \n'email'\n,\n \n'is_admin'\n))\n\n\n    \n# WITH types\n\n    \nuser_created\n \n=\n \nEvent\n(\nparameters\n=\n(\n\n        \nParameter\n(\n'username'\n,\n \nstr\n),\n\n        \nParameter\n(\n'new_email'\n,\n \nstr\n),\n\n        \nParameter\n(\n'is_admin'\n,\n \nbool\n,\n \ndefault\n=\nFalse\n),\n\n    \n))\n\n\n\n\n\nThis will:\n\n\n\n\nEnsure the received \nusername\n parameter is a string\n\n\nEnsure the received \nnew_email\n parameter is a string\n\n\nEnsure the received \nis_admin\n parameter is a boolean.\n  If omitted, \nFalse\n will be used.\n\n\n\n\nThis behaviour can be configured via the \nvalidate\n configuration option\n.\n\n\nData structures\n\u00b6\n\n\nIn additional to built in types, Lightbus can derive typing information from\nthe following data structures:\n\n\n\n\nNamed Tuples\n\n\nDataclasses\n\n\nAny class defining the \n__to_bus__\n and \n__from_bus__\n methods\n\n\n\n\nFor each of these data structures Lightbus will:\n\n\n\n\nEncode values as JSON objects (i.e. dictionaries)\n\n\nUse the structure's type hints in generating the JSON schema...\n\n\n... and therefore validate incoming/outgoing objects against this schema\n\n\n\n\nNamedTuple example\n\u00b6\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\nfrom\n \ntyping\n \nimport\n \nNamedTuple\n\n\n\n\nclass\n \nUser\n(\nNamedTuple\n):\n\n    \nusername\n:\n \nstr\n\n    \nname\n:\n \nstr\n\n    \nemail\n:\n \nstr\n\n    \nis_admin\n:\n \nbool\n \n=\n \nFalse\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n:\n \nstr\n)\n \n->\n \nUser\n:\n\n        \nreturn\n \n...\n\n\n\n\n\nDataclass example\n\u00b6\n\n\nDataclasses\n\nwere introduced in Python 3.7, with a\n\nbackport available\n for\nPython 3.6.\n\n\nLightbus supports dataclasses in the same way as it supports\n\nnamed tuples\n. For example:\n\n\n# bus.py\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\nfrom\n \ndataclasses\n \nimport\n \ndataclass\n\n\n\n@dataclass\n()\n\n\nclass\n \nUser\n(\nobject\n):\n\n    \nusername\n:\n \nstr\n\n    \nname\n:\n \nstr\n\n    \nemail\n:\n \nstr\n\n    \nis_admin\n:\n \nbool\n \n=\n \nFalse\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n:\n \nstr\n)\n \n->\n \nUser\n:\n\n        \nreturn\n \n...\n\n\n\n\n\nCustom class example\n\u00b6\n\n\nLightbus can also work with classes of any type provided that:\n\n\n\n\nThe class defines a \n__from_bus__(self, value: dict)\n class method, which returns an instance of the class.\n\n\nThe class defines a \n__to_bus__(self)\n method, which returns a \ndict\n.\n\n\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n\n\n\n\nclass\n \nUser\n(\nobject\n):\n\n    \nusername\n:\n \nstr\n\n    \nname\n:\n \nstr\n\n    \nemail\n:\n \nstr\n\n    \nis_admin\n:\n \nbool\n \n=\n \nFalse\n\n\n    \ndef\n \ndo_something\n(\nself\n):\n\n        \npass\n\n\n    \n@classmethod\n\n    \ndef\n \n__from_bus__\n(\ncls\n,\n \nvalue\n):\n\n        \nuser\n \n=\n \ncls\n()\n\n        \nuser\n.\nusername\n \n=\n \nvalue\n[\n\"username\"\n]\n\n        \nuser\n.\nname\n \n=\n \nvalue\n[\n\"name\"\n]\n\n        \nuser\n.\nemail\n \n=\n \nvalue\n[\n\"email\"\n]\n\n        \nuser\n.\nis_admin\n \n=\n \nvalue\n.\nget\n(\n\"is_admin\"\n,\n \nFalse\n)\n\n        \nreturn\n \nuser\n\n\n    \ndef\n \n__to_bus__\n():\n\n        \nreturn\n \ndict\n(\n\n            \nusername\n=\nusername\n,\n\n            \nname\n=\nname\n,\n\n            \nemail\n=\nemail\n,\n\n            \nis_admin\n=\nis_admin\n,\n\n        \n)\n\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \ndef\n \nget_user\n(\nself\n,\n \nusername\n:\n \nstr\n)\n \n->\n \nUser\n:\n\n        \nreturn\n \n...",
            "title": "Typing"
        },
        {
            "location": "/reference/typing/#typing-syntax-for-rpcs",
            "text": "You can provide typing information for Remote Procedure Calls using\nregular Python type hinting:  class   AuthApi ( lightbus . Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   check_password ( self ,   username :   str ,   password :   str )   ->   bool : \n         return   username   ==   'admin'   and   password   ==   'secret'   This will:   Ensure the received  username  parameter is a string  Ensure the received  password  parameter is a string  Ensure the returned value is a boolean   This behaviour can be configured via the  validate  configuration option .",
            "title": "Typing syntax for RPCs"
        },
        {
            "location": "/reference/typing/#typing-syntax-for-events",
            "text": "Typing information for events is different to that for RPCs.\nFirstly, events do not provide return values. Secondly, event\nparameters are specified differently:  # auth_service/bus.py  from   lightbus   import   Api ,   Event ,   Parameter  class   AuthApi ( Api ): \n     # WITHOUT types \n     user_created   =   Event ( parameters = ( 'username' ,   'email' ,   'is_admin' )) \n\n     # WITH types \n     user_created   =   Event ( parameters = ( \n         Parameter ( 'username' ,   str ), \n         Parameter ( 'new_email' ,   str ), \n         Parameter ( 'is_admin' ,   bool ,   default = False ), \n     ))   This will:   Ensure the received  username  parameter is a string  Ensure the received  new_email  parameter is a string  Ensure the received  is_admin  parameter is a boolean.\n  If omitted,  False  will be used.   This behaviour can be configured via the  validate  configuration option .",
            "title": "Typing syntax for events"
        },
        {
            "location": "/reference/typing/#data-structures",
            "text": "In additional to built in types, Lightbus can derive typing information from\nthe following data structures:   Named Tuples  Dataclasses  Any class defining the  __to_bus__  and  __from_bus__  methods   For each of these data structures Lightbus will:   Encode values as JSON objects (i.e. dictionaries)  Use the structure's type hints in generating the JSON schema...  ... and therefore validate incoming/outgoing objects against this schema",
            "title": "Data structures"
        },
        {
            "location": "/reference/typing/#namedtuple-example",
            "text": "# bus.py  from   lightbus   import   Api  from   typing   import   NamedTuple  class   User ( NamedTuple ): \n     username :   str \n     name :   str \n     email :   str \n     is_admin :   bool   =   False  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   get_user ( self ,   username :   str )   ->   User : \n         return   ...",
            "title": "NamedTuple example"
        },
        {
            "location": "/reference/typing/#dataclass-example",
            "text": "Dataclasses \nwere introduced in Python 3.7, with a backport available  for\nPython 3.6.  Lightbus supports dataclasses in the same way as it supports named tuples . For example:  # bus.py  from   lightbus   import   Api  from   dataclasses   import   dataclass  @dataclass ()  class   User ( object ): \n     username :   str \n     name :   str \n     email :   str \n     is_admin :   bool   =   False  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   get_user ( self ,   username :   str )   ->   User : \n         return   ...",
            "title": "Dataclass example"
        },
        {
            "location": "/reference/typing/#custom-class-example",
            "text": "Lightbus can also work with classes of any type provided that:   The class defines a  __from_bus__(self, value: dict)  class method, which returns an instance of the class.  The class defines a  __to_bus__(self)  method, which returns a  dict .   from   lightbus   import   Api  class   User ( object ): \n     username :   str \n     name :   str \n     email :   str \n     is_admin :   bool   =   False \n\n     def   do_something ( self ): \n         pass \n\n     @classmethod \n     def   __from_bus__ ( cls ,   value ): \n         user   =   cls () \n         user . username   =   value [ \"username\" ] \n         user . name   =   value [ \"name\" ] \n         user . email   =   value [ \"email\" ] \n         user . is_admin   =   value . get ( \"is_admin\" ,   False ) \n         return   user \n\n     def   __to_bus__ (): \n         return   dict ( \n             username = username , \n             name = name , \n             email = email , \n             is_admin = is_admin , \n         )  class   AuthApi ( Api ): \n\n     class   Meta : \n         name   =   'auth' \n\n     def   get_user ( self ,   username :   str )   ->   User : \n         return   ...",
            "title": "Custom class example"
        },
        {
            "location": "/reference/transports/",
            "text": "TBA",
            "title": "Transports*"
        },
        {
            "location": "/reference/configuration/",
            "text": "Lightbus' configuration happens in three stages:\n\n\n\n\nModule loading\n \u2013 Lightbus discovers where your \nbus.py\n file can found via the \nLIGHTBUS_MODULE\n environment variable.\n\n\nService-level configuration\n \u2013 Your \nbus.py\n file specifies service-level settings (\nservice_name\n and \nprocess_name\n)\n\n\nGlobal bus configuration\n \u2013 Your \nbus.py\n provides the location to the global config for your bus.\n\n\n\n\n1. Module loading\n\u00b6\n\n\nThe first stage in Lightbus' startup is to import your \nbus.py\n module.\nBy default Lightbus will attempt to import a module named \nbus\n,\nbut you can modify this by specifying the \nLIGHTBUS_MODULE\n\nenvironment variable.\n\n\nThis stage is only required when starting a [Lightbus process]\n(i.e. \nlightbus run\n).\n\n\n[Non-lightbus processes] will import the bus module manually in order\nto access the bus client within (see next stage, below).\n\n\n2. Service-level configuration\n\u00b6\n\n\nThe \nbus\n module discovered in the module loading stage (above)\nmust define a Lightbus client as follows:\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n()\n\n\n\n\n\nThis serves several purposes:\n\n\n\n\nlightbus run\n will use this client to access the bus.\n\n\nYou can (and should) import this client\n   elsewhere in the service in order to call RPCs and fire events.\n\n\nYou can configure service-level configuration options for your\n   Lightbus client.\n\n\n\n\nService-level configuration is different to your global configuration\nbecause the values will vary between services.\n\n\nThe following service-level options are available:\n\n\nbus\n \n=\n \nlightbus\n.\ncreate\n(\n\n    \n# Relevent to event consumption\n\n    \nservice_name\n=\n'my_service'\n,\n\n\n    \n# Will be replaced 4 random characters. Default\n\n    \nprocess_name\n=\n'\n{random4}\n'\n,\n\n\n    \n# Global bus config. Can be path to file or URL\n\n    \nconifg\n=\n'http://internal.mysite.com/bus/lightbus.yaml'\n,\n\n\n)\n\n\n\n\n\nThe above configuration options can also be set using the following\nenvironment variables:\n\n\n\n\nLIGHTBUS_SERVICE_NAME\n\n\nLIGHTBUS_PROCESS_NAME\n\n\nLIGHTBUS_CONFIG\n\n\n\n\nService & process name placeholders\n\u00b6\n\n\nThe following placeholders may be used within your service and\nprocess name values:\n\n\n\n\n\n\n\n\nPaceholder\n\n\nExample value\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n{hostname}\n\n\nmy-host\n\n\nLower case hostname\n\n\n\n\n\n\n{pid}\n\n\n12345\n\n\nThe process' ID\n\n\n\n\n\n\n{random4}\n\n\nabcd\n\n\nRandom 4-character string\n\n\n\n\n\n\n{random8}\n\n\nabcdefgh\n\n\nRandom 8-character string\n\n\n\n\n\n\n{random16}\n\n\nabcdefghijklmnop\n\n\nRandom 16-character string\n\n\n\n\n\n\n{friendly}\n\n\ndelicate-wave-915\n\n\nHuman-friendly random name\n\n\n\n\n\n\n\n\nEvent delivery\n\u00b6\n\n\nSee the \nevents explanation section\n for a discussion on how\nservice & process names affect event delivery.\n\n\n3. Global bus configuration\n\u00b6\n\n\nThe global bus configuration specifies the bus' overall architecture.\nThis takes the form of a YAML or JSON file. This file is typically\nshared by all lightbus clients.\n\n\nA basic default configuration is as follows:\n\n\n# Root config\n\n\nbus\n:\n\n  \n# Bus config\n\n\n  \nschema\n:\n\n    \n# Schema config\n\n\n    \ntransport\n:\n\n      \n# Transport selector config\n\n\n      \nredis\n:\n\n        \nurl\n:\n \n\"redis://redis.svc.cluster.local:6379/0\"\n\n\n\napis\n:\n\n  \n# API configuration listing\n\n\n  \ndefault\n:\n\n    \n# Api config\n\n\n    \nevent_transport\n:\n\n      \n# Transport selector config\n\n      \nredis\n:\n\n        \nurl\n:\n \n\"redis://redis.svc.cluster.local:6379/0\"\n\n\n    \nrpc_transport\n:\n\n      \n# Transport selector config\n\n      \nredis\n:\n\n        \nurl\n:\n \n\"redis://redis.svc.cluster.local:6379/0\"\n\n\n    \nresult_transport\n:\n\n      \n# Transport selector config\n\n      \nredis\n:\n\n        \nurl\n:\n \n\"redis://redis.svc.cluster.local:6379/0\"\n\n\n\n\n\nEach section is detailed below.\n\n\nRoot config\n\u00b6\n\n\nThe available root-level configuration keys are:\n\n\n\n\nbus\n \u2013 Contains the \nbus config\n\n\napis\n \u2013 Contains the \nAPI configuration listing\n\n\nplugins\n - Contains the \nplugin configuration listing\n\n\n\n\nThe following keys are also present, but \nshould\ngenerally not be specified in your global yaml file\n.\nInstead they should be specified for each service, as\nper the \nservice-level setup\n:\n\n\n\n\nservice_name\n \u2013 Service name\n\n\nprocess_name\n \u2013 Process name\n\n\n\n\nBus config\n\u00b6\n\n\nThe bus config resides under the \nroot config\n. It contains the\nfollowing keys:\n\n\n\n\nlog_level\n (default: \ninfo\n) - The log level for the \nlightbus\n logger. One of\n  \ndebug\n, \ninfo\n, \nwarning\n, \nerror\n, \ncritical\n. \ninfo\n is a good level\n  for development purposes, \nwarning\n will be more suited to production.\n\n\nschema\n - Contains the \nschema config\n\n\n\n\nAPI configuration listing\n\u00b6\n\n\nThe schema config resides under the \nroot config\n.\n\n\nThis is a key/value association between APIs and their configurations.\nThe reserved API name of \ndefault\n provides a catch-all configuration\nfor any APIs without specific configurations. Specifically configured\nAPIs do not inherit from the default configuration.\n\n\nFor example:\n\n\n...\n\n\napis\n:\n\n\n  \n# Catch-all api config\n\n  \ndefault\n:\n\n      \n... default config as above ...\n\n\n  \n# Specific config for the 'marketing.analytics' API.\n\n  \n# Use a different Redis instance for the high\n\n  \n# volume marketing analytics\n\n  \nmarketing.analytics\n:\n\n    \n# See 'API config'\n\n    \nvalidate\n:\n \nfalse\n\n    \ncast_values\n:\n \nfalse\n\n\n    \nevent_transport\n:\n\n      \nredis\n:\n\n        \nurl\n:\n \n\"redis://redis-marketing.svc.cluster.local:6379/0\"\n\n\n    \nrpc_transport\n:\n\n      \nredis\n:\n\n        \nurl\n:\n \n\"redis://redis-marketing.svc.cluster.local:6379/0\"\n\n\n    \nresult_transport\n:\n\n      \nredis\n:\n\n        \nurl\n:\n \n\"redis://redis-marketing.svc.cluster.local:6379/0\"\n\n\n\n\n\nSee \nAPI config\n for further details on the API options available.\n\n\nAPI config\n\u00b6\n\n\nThe API config resides under the \nAPI configuration listing\n.\n\n\nEach API can be individually configured using the options below:\n\n\n\n\nrpc_timeout\n (default: \n5\n) \u2013 Timeout when calling RPCs on this API\n\n\nevent_listener_setup_timeout\n (default: \n1\n) \u2013 Timeout seconds when setting up event listeners\n  (only applies when using the blocking api)\n\n\nevent_fire_timeout\n (default: \n1\n) \u2013 Timeout seconds when firing events on the bus\n  (only applies when using the blocking api)\n\n\nvalidate\n \u2013 Contains the \napi validation config\n. May also be set to\n  boolean \ntrue\n or \nfalse\n to blanket enable/disable.\n\n\nstrict_validation\n (default: \nfalse\n) \u2013 Raise an exception if we receive a message\n  from an API for which there is no schema available on the bus. If \nfalse\n\n  a warning will be emitted instead.\n\n\nevent_transport\n \u2013 Contains the \ntransport selector\n.\n\n\nrpc_transport\n \u2013 Contains the \ntransport selector\n.\n\n\nresult_transport\n  \u2013 Contains the \ntransport selector\n.\n\n\ncast_values\n (default: \ntrue\n) \u2013 If enabled, incoming values will be best-effort\n  casted based on the annotations of the RPC method signature or event listener.\n  See \ntyping\n.\n\n\non_error\n (default: \nshutdown\n) \u2013 How should errors in event handlers be\n  dealt with. Must be one of \nignore\n, \nstop_listener\n, or \nshutdown\n.\n  In all cases the exception will be logged. \nignore\n will simply log the error and\n  continue processing events. \nstop_listener\n will consume no further events\n  for that listener, but other event listeners will continue as normal.\n  \nshutdown\n will cause the Lightbus process to exit with a non-zero exit code.\n\n\n\n\nSchema config\n\u00b6\n\n\nThe schema config resides under the \nbus config\n.\n\n\n\n\nhuman_readable\n (default: \nTrue\n) \u2013 Should the schema JSON be transmitted\n  with human-friendly indentation and spacing?\n\n\nttl\n (default: \n60\n) \u2013 Integer number of seconds that an API schema should\n  live on the bus. Each schema will be pinged every \nttl * 0.8\n seconds\n  in order to keep it alive. The bus will also check for new remote schemas\n  every \nttl * 0.8\n seconds.\n\n\ntransport\n \u2013 Contains the schema \ntransport selector\n\n\n\n\nTransport selector\n\u00b6\n\n\nThe schema config resides under both the \nAPI config\n and the\n\nschema config\n.\n\n\nTransports are specifed as follows:\n\n\n... parent yaml ...\n    [transport-name]:\n        option: \"value\"\n        option: \"value\"\n\n\n\n\nWhere \n[transport-name]\n can be one of:\n\n\n\n\nredis\n \u2013 The redis-backed transport.\n\n\ndebug\n \u2013 A debug transport which logs what happens but\n            takes no further action.\n\n\n\n\nThe table below details which transports can be used in which\nsituations\n\n\n\n\n\n\n\n\nTransport\n\n\nRPC\n\n\nResult\n\n\nEvent\n\n\nSchema\n\n\n\n\n\n\n\n\n\n\nredis\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\ndebug\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\nAdditional transports may be added in future. A single API\ncan use different types for each of its \nrpc\n, \nresult\n,\nand \nevent\n needs.\n\n\nThe \nschema\n transport is global to the bus, and is not\nconfigurable on a per-api level.\n\n\nFor more information see \ntransports\n.\n\n\nAPI validation config\n\u00b6\n\n\nThe schema config resides under the \nvalidate\n key within\nthe \nAPI config\n.\n\n\nAvailable options are:\n\n\n\n\noutgoing\n (default \ntrue\n) \u2013 Validate outgoing messages against any\n  available API schema.\n\n\nincoming\n (default \ntrue\n) \u2013 Validate incoming messages against any\n  available API schema.\n\n\n\n\nA warning will be emitted if validation is enabled and the schema\nis not present on the bus.\nYou can turn this into an error by enabling \nstrict_validation\n\nwithin the \nAPI config\n.",
            "title": "Configuration"
        },
        {
            "location": "/reference/configuration/#1-module-loading",
            "text": "The first stage in Lightbus' startup is to import your  bus.py  module.\nBy default Lightbus will attempt to import a module named  bus ,\nbut you can modify this by specifying the  LIGHTBUS_MODULE \nenvironment variable.  This stage is only required when starting a [Lightbus process]\n(i.e.  lightbus run ).  [Non-lightbus processes] will import the bus module manually in order\nto access the bus client within (see next stage, below).",
            "title": "1. Module loading"
        },
        {
            "location": "/reference/configuration/#2-service-level-configuration",
            "text": "The  bus  module discovered in the module loading stage (above)\nmust define a Lightbus client as follows:  bus   =   lightbus . create ()   This serves several purposes:   lightbus run  will use this client to access the bus.  You can (and should) import this client\n   elsewhere in the service in order to call RPCs and fire events.  You can configure service-level configuration options for your\n   Lightbus client.   Service-level configuration is different to your global configuration\nbecause the values will vary between services.  The following service-level options are available:  bus   =   lightbus . create ( \n     # Relevent to event consumption \n     service_name = 'my_service' , \n\n     # Will be replaced 4 random characters. Default \n     process_name = ' {random4} ' , \n\n     # Global bus config. Can be path to file or URL \n     conifg = 'http://internal.mysite.com/bus/lightbus.yaml' ,  )   The above configuration options can also be set using the following\nenvironment variables:   LIGHTBUS_SERVICE_NAME  LIGHTBUS_PROCESS_NAME  LIGHTBUS_CONFIG",
            "title": "2. Service-level configuration"
        },
        {
            "location": "/reference/configuration/#service-process-name-placeholders",
            "text": "The following placeholders may be used within your service and\nprocess name values:     Paceholder  Example value  Notes      {hostname}  my-host  Lower case hostname    {pid}  12345  The process' ID    {random4}  abcd  Random 4-character string    {random8}  abcdefgh  Random 8-character string    {random16}  abcdefghijklmnop  Random 16-character string    {friendly}  delicate-wave-915  Human-friendly random name",
            "title": "Service &amp; process name placeholders"
        },
        {
            "location": "/reference/configuration/#event-delivery",
            "text": "See the  events explanation section  for a discussion on how\nservice & process names affect event delivery.",
            "title": "Event delivery"
        },
        {
            "location": "/reference/configuration/#3-global-bus-configuration",
            "text": "The global bus configuration specifies the bus' overall architecture.\nThis takes the form of a YAML or JSON file. This file is typically\nshared by all lightbus clients.  A basic default configuration is as follows:  # Root config  bus : \n   # Bus config \n\n   schema : \n     # Schema config \n\n     transport : \n       # Transport selector config \n\n       redis : \n         url :   \"redis://redis.svc.cluster.local:6379/0\"  apis : \n   # API configuration listing \n\n   default : \n     # Api config \n\n     event_transport : \n       # Transport selector config \n       redis : \n         url :   \"redis://redis.svc.cluster.local:6379/0\" \n\n     rpc_transport : \n       # Transport selector config \n       redis : \n         url :   \"redis://redis.svc.cluster.local:6379/0\" \n\n     result_transport : \n       # Transport selector config \n       redis : \n         url :   \"redis://redis.svc.cluster.local:6379/0\"   Each section is detailed below.",
            "title": "3. Global bus configuration"
        },
        {
            "location": "/reference/configuration/#root-config",
            "text": "The available root-level configuration keys are:   bus  \u2013 Contains the  bus config  apis  \u2013 Contains the  API configuration listing  plugins  - Contains the  plugin configuration listing   The following keys are also present, but  should\ngenerally not be specified in your global yaml file .\nInstead they should be specified for each service, as\nper the  service-level setup :   service_name  \u2013 Service name  process_name  \u2013 Process name",
            "title": "Root config"
        },
        {
            "location": "/reference/configuration/#bus-config",
            "text": "The bus config resides under the  root config . It contains the\nfollowing keys:   log_level  (default:  info ) - The log level for the  lightbus  logger. One of\n   debug ,  info ,  warning ,  error ,  critical .  info  is a good level\n  for development purposes,  warning  will be more suited to production.  schema  - Contains the  schema config",
            "title": "Bus config"
        },
        {
            "location": "/reference/configuration/#api-configuration-listing",
            "text": "The schema config resides under the  root config .  This is a key/value association between APIs and their configurations.\nThe reserved API name of  default  provides a catch-all configuration\nfor any APIs without specific configurations. Specifically configured\nAPIs do not inherit from the default configuration.  For example:  ...  apis : \n\n   # Catch-all api config \n   default : \n       ... default config as above ... \n\n   # Specific config for the 'marketing.analytics' API. \n   # Use a different Redis instance for the high \n   # volume marketing analytics \n   marketing.analytics : \n     # See 'API config' \n     validate :   false \n     cast_values :   false \n\n     event_transport : \n       redis : \n         url :   \"redis://redis-marketing.svc.cluster.local:6379/0\" \n\n     rpc_transport : \n       redis : \n         url :   \"redis://redis-marketing.svc.cluster.local:6379/0\" \n\n     result_transport : \n       redis : \n         url :   \"redis://redis-marketing.svc.cluster.local:6379/0\"   See  API config  for further details on the API options available.",
            "title": "API configuration listing"
        },
        {
            "location": "/reference/configuration/#api-config",
            "text": "The API config resides under the  API configuration listing .  Each API can be individually configured using the options below:   rpc_timeout  (default:  5 ) \u2013 Timeout when calling RPCs on this API  event_listener_setup_timeout  (default:  1 ) \u2013 Timeout seconds when setting up event listeners\n  (only applies when using the blocking api)  event_fire_timeout  (default:  1 ) \u2013 Timeout seconds when firing events on the bus\n  (only applies when using the blocking api)  validate  \u2013 Contains the  api validation config . May also be set to\n  boolean  true  or  false  to blanket enable/disable.  strict_validation  (default:  false ) \u2013 Raise an exception if we receive a message\n  from an API for which there is no schema available on the bus. If  false \n  a warning will be emitted instead.  event_transport  \u2013 Contains the  transport selector .  rpc_transport  \u2013 Contains the  transport selector .  result_transport   \u2013 Contains the  transport selector .  cast_values  (default:  true ) \u2013 If enabled, incoming values will be best-effort\n  casted based on the annotations of the RPC method signature or event listener.\n  See  typing .  on_error  (default:  shutdown ) \u2013 How should errors in event handlers be\n  dealt with. Must be one of  ignore ,  stop_listener , or  shutdown .\n  In all cases the exception will be logged.  ignore  will simply log the error and\n  continue processing events.  stop_listener  will consume no further events\n  for that listener, but other event listeners will continue as normal.\n   shutdown  will cause the Lightbus process to exit with a non-zero exit code.",
            "title": "API config"
        },
        {
            "location": "/reference/configuration/#schema-config",
            "text": "The schema config resides under the  bus config .   human_readable  (default:  True ) \u2013 Should the schema JSON be transmitted\n  with human-friendly indentation and spacing?  ttl  (default:  60 ) \u2013 Integer number of seconds that an API schema should\n  live on the bus. Each schema will be pinged every  ttl * 0.8  seconds\n  in order to keep it alive. The bus will also check for new remote schemas\n  every  ttl * 0.8  seconds.  transport  \u2013 Contains the schema  transport selector",
            "title": "Schema config"
        },
        {
            "location": "/reference/configuration/#transport-selector",
            "text": "The schema config resides under both the  API config  and the schema config .  Transports are specifed as follows:  ... parent yaml ...\n    [transport-name]:\n        option: \"value\"\n        option: \"value\"  Where  [transport-name]  can be one of:   redis  \u2013 The redis-backed transport.  debug  \u2013 A debug transport which logs what happens but\n            takes no further action.   The table below details which transports can be used in which\nsituations     Transport  RPC  Result  Event  Schema      redis  \u2714  \u2714  \u2714  \u2714    debug  \u2714  \u2714  \u2714  \u2714     Additional transports may be added in future. A single API\ncan use different types for each of its  rpc ,  result ,\nand  event  needs.  The  schema  transport is global to the bus, and is not\nconfigurable on a per-api level.  For more information see  transports .",
            "title": "Transport selector"
        },
        {
            "location": "/reference/configuration/#api-validation-config",
            "text": "The schema config resides under the  validate  key within\nthe  API config .  Available options are:   outgoing  (default  true ) \u2013 Validate outgoing messages against any\n  available API schema.  incoming  (default  true ) \u2013 Validate incoming messages against any\n  available API schema.   A warning will be emitted if validation is enabled and the schema\nis not present on the bus.\nYou can turn this into an error by enabling  strict_validation \nwithin the  API config .",
            "title": "API validation config"
        },
        {
            "location": "/reference/schema/",
            "text": "Lightbus processes automatically generate and share schemas for their available APIs.\nThese schemes can be used to validate the following:\n\n\n\n\nRemote procedure call parameters\n\n\nRemote procedure call return values\n\n\nEvent parameters\n\n\n\n\nThese schemas are shared using the configured \nSchemaTransprt\n (Redis, by default).\nEach Lightbus process will monitor for any schema changes.\n\n\nSpecifying types\n\u00b6\n\n\nLightbus will create a schema by inspecting the parameters\nand \ntype hints\n of your APIs' events and procedures.\n\n\nYou can use the schema functionality without type hints, but the level of validation\nprovided will be limited to ensuring parameter names match what is expected.\n\n\nTake the following API as an example:\n\n\nfrom\n \nlightbus\n \nimport\n \nApi\n,\n \nEvent\n,\n \nParameter\n\n\n\nclass\n \nAuthApi\n(\nApi\n):\n\n    \n# Here we specify event parameters in the long-form using Parameter().\n\n    \n# This provides sufficient information for the schema to be generated\n\n    \nuser_registered\n \n=\n \nEvent\n(\nparameters\n=\n(\n\n        \nParameter\n(\n'username'\n,\n \nstr\n),\n\n        \nParameter\n(\n'email'\n,\n \nstr\n),\n\n        \nParameter\n(\n'is_admin'\n,\n \nbool\n,\n \ndefault\n=\nFalse\n),\n\n    \n))\n\n\n    \nclass\n \nMeta\n:\n\n        \nname\n \n=\n \n'auth'\n\n\n    \n# We annotate check_password() with the apropriate types\n\n    \ndef\n \ncheck_password\n(\nself\n,\n \nusername\n:\n \nstr\n,\n \npassword\n:\n \nstr\n)\n \n->\n \nbool\n:\n\n        \nreturn\n \nusername\n \n==\n \n'admin'\n \nand\n \npassword\n \n==\n \n'secret'\n\n\n\n\n\nCreate this in a \nbus.py\n and run:\n\n\n$ lightbus dumpschema\n\n\n\n\nThis will dump out the auto-generated schema for the above API. See\n\nschema format\n (below) for example output.\n\n\nSupported data types\n\u00b6\n\n\nLightbus maps Python types to JSON types. While Python-specific values can be sent using Lightbus,\nthese values will arrive in their JSON form. For example, if you send a \nstring\n then a \nstring\n will arrive.\nHowever, if you send the \nDecimal\n value \n3.124\n, then you will receive the \nstring\n value \n3.124\n instead.\n\n\nThe following types are reasonably interoperable:\n\n\n\n\n\n\n\n\nPython type sent\n\n\nJSON schema interpretation\n\n\nType received\n\n\n\n\n\n\n\n\n\n\nstr\n\n\nstring\n\n\nstr\n\n\n\n\n\n\nint\n, \nfloat\n\n\nnumber\n\n\nint\n, \nfloat\n\n\n\n\n\n\nbool\n\n\nboolean\n\n\nbool\n\n\n\n\n\n\nlist\n, \ntuple\n\n\narray\n\n\nlist\n\n\n\n\n\n\nNone\n\n\nnull\n\n\nNone\n\n\n\n\n\n\ndict\n, \nMapping\n, etc\n\n\nobject\n\n\ndict\n\n\n\n\n\n\nMapping[str, ...]\n\n\nobject\n, with \npattern properties\n set\n\n\ndict\n\n\n\n\n\n\nTuple[A, B, C]\n\n\narray\n with \nmaxItems/minItems\n and \nitems\n set.\n\n\nlist\n\n\n\n\n\n\n\n\nThe following types will be successfully encoded and sent, but will arrive as their encoded equivalent:\n\n\n\n\n\n\n\n\nPython type\n\n\nJSON Schema type\n\n\nValue arrives as\n\n\n\n\n\n\n\n\n\n\nbytes\n, \nDecimal\n, \ncomplex\n\n\nstring\n\n\nstr\n\n\n\n\n\n\ndatetime\n, \ndate\n\n\nstr\n\n\nstr\n (ISO 8601)\n\n\n\n\n\n\nNamedTuple\n with annotations\n\n\nobject\n with \nspecific typed properties\n\n\ndict\n\n\n\n\n\n\nobject\n with annotations\n\n\nobject\n with \nspecific typed properties\n\n\ndict\n\n\n\n\n\n\n\n\nLightbus can also handle the following:\n\n\n\n\n\n\n\n\nPython type\n\n\nJSON Schema type\n\n\n\n\n\n\n\n\n\n\nAny\n\n\n{}\n (any value)\n\n\n\n\n\n\nUnion[...]\n\n\noneOf{...}\n (see \noneOf\n)\n\n\n\n\n\n\nEnum\n\n\nSets \nenum\n property\n\n\n\n\n\n\n\n\nAutomatic validation\n\u00b6\n\n\nBy default this validation will be validated in both the\nincoming and outgoing directions. Outgoing refers to\nthe dispatching of events or procedure calls to the bus.\nIncoming refers to the processing of procedure calls or\nhandling of received events.\n\n\nYou can configuring this using the \nvalidate\n\n\nconfiguration\n option.\n\n\nValidation configuration\n\u00b6\n\n\nYou can configure the validation behaviour in your\nbus' \nconfig.yaml\n.\n\n\nvalidate (bool) = true\n\u00b6\n\n\nYou can enable/disable validation using a boolean true/false flag:\n\n\n# In config.yaml\n\n\napis:\n\n    \ndefault:\n\n        \nvalidate: \nfalse\n\n\n\n\n\nFor finer grained control you can specify individual flags for incoming/outgoing\nvalidation:\n\n\n# In config.yaml\n\n\napis:\n\n    \ndefault:\n\n        \nvalidate:\n\n          \noutgoing: \ntrue\n\n          \nincoming: \nfalse\n\n\n\n\n\nstrict_validation (bool) = false\n\u00b6\n\n\nIf \nstrict_validation\n is \ntrue\n then calling a procedure for which no schema exists will\nresult in an error:\n\n\n# In config.yaml\n\n\napis:\n\n    \ndefault:\n\n        \nstrict_validation: \ntrue\n\n\n\n\n\nManual validation\n\u00b6\n\n\nTODO\n\n\nSchema format\n\u00b6\n\n\nYou won't need to worry about the schema format in your day-to-day use\nof Lightbus. However, an understanding of the format will be very\nuseful if you decide to build additional tooling.\n\n\nThe Lightbus schema format is simply a collection of child JSON Schemas.\nBelow is the schema for the example \nauth\n API shown above:\n\n\n//\n \nAuto-generated\n \nschema\n \nfor\n \nauth\n \nAPI\n\n\n{\n\n  \n\"auth\"\n:\n \n{\n\n\n    \n//\n \nEvents\n \nspecify\n \nonly\n \nparameters\n\n    \n\"events\"\n:\n \n{\n\n      \n\"user_registered\"\n:\n \n{\n\n        \n\"parameters\"\n:\n \n{\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"Event auth.user_registered parameters\"\n,\n\n          \n\"type\"\n:\n \n\"object\"\n,\n\n            \n\"username\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n          \n\"properties\"\n:\n \n{\n\n            \n\"email\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n            \n\"is_admin\"\n:\n \n{\n\n              \n\"default\"\n:\n \nfalse\n,\n\n              \n\"type\"\n:\n \n\"boolean\"\n\n            \n}\n\n          \n},\n\n          \n\"required\"\n:\n \n[\n\n            \n\"username\"\n,\n\n            \n\"email\"\n\n          \n],\n\n          \n\"additionalProperties\"\n:\n \nfalse\n\n        \n}\n\n      \n}\n\n    \n},\n\n\n    \n//\n \nRPCs\n \nspecify\n \nboth\n \nparameters\n \nand\n \nresponse\n\n    \n\"rpcs\"\n:\n \n{\n\n      \n\"check_password\"\n:\n \n{\n\n        \n\"parameters\"\n:\n \n{\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"RPC auth.check_password() parameters\"\n,\n\n          \n\"type\"\n:\n \n\"object\"\n,\n\n          \n\"properties\"\n:\n \n{\n\n            \n\"username\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n},\n\n            \n\"password\"\n:\n \n{\n\n              \n\"type\"\n:\n \n\"string\"\n\n            \n}\n\n          \n},\n\n          \n\"required\"\n:\n \n[\n\n            \n\"username\"\n,\n\n            \n\"password\"\n\n          \n],\n\n          \n\"additionalProperties\"\n:\n \nfalse\n\n        \n},\n\n\n        \n\"response\"\n:\n \n{\n\n          \n\"$schema\"\n:\n \n\"http://json-schema.org/draft-04/schema#\"\n,\n\n          \n\"title\"\n:\n \n\"RPC auth.check_password() response\"\n,\n\n          \n\"type\"\n:\n \n\"boolean\"\n\n        \n}\n\n      \n}\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\nThe generalised format is as follows:\n\n\n//\n \nGeneralised\n \nLightbus\n \nschema\n \nformat\n\n\n{\n\n  \n\"<api-name>\"\n:\n \n{\n\n\n    \n\"events\"\n:\n \n{\n\n      \n\"<event-name>\"\n:\n \n{\n\n        \n\"parameters\"\n:\n  \n{\n \n/*\n \njson\n \nschema\n \n*/\n \n}\n\n      \n}\n\n      \n//\n \nadditional\n \nevents\n\n    \n},\n\n\n    \n\"rpcs\"\n:\n \n{\n\n      \n\"<rpc-name>\"\n:\n \n{\n\n        \n\"parameters\"\n:\n \n{\n \n/*\n \njson\n \nschema\n \n*/\n \n},\n\n        \n\"response\"\n:\n \n{\n \n/*\n \njson\n \nschema\n \n*/\n \n}\n\n      \n}\n\n      \n//\n \nadditional\n \nprocedures\n\n    \n}\n\n\n  \n}\n\n  \n//\n \nadditional\n \nAPIs\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nLightbus will likely upgrade to a newer JSON Schema version once the \njsonschema Python library\n has the \nrequisite support\n.",
            "title": "Schema"
        },
        {
            "location": "/reference/schema/#specifying-types",
            "text": "Lightbus will create a schema by inspecting the parameters\nand  type hints  of your APIs' events and procedures.  You can use the schema functionality without type hints, but the level of validation\nprovided will be limited to ensuring parameter names match what is expected.  Take the following API as an example:  from   lightbus   import   Api ,   Event ,   Parameter  class   AuthApi ( Api ): \n     # Here we specify event parameters in the long-form using Parameter(). \n     # This provides sufficient information for the schema to be generated \n     user_registered   =   Event ( parameters = ( \n         Parameter ( 'username' ,   str ), \n         Parameter ( 'email' ,   str ), \n         Parameter ( 'is_admin' ,   bool ,   default = False ), \n     )) \n\n     class   Meta : \n         name   =   'auth' \n\n     # We annotate check_password() with the apropriate types \n     def   check_password ( self ,   username :   str ,   password :   str )   ->   bool : \n         return   username   ==   'admin'   and   password   ==   'secret'   Create this in a  bus.py  and run:  $ lightbus dumpschema  This will dump out the auto-generated schema for the above API. See schema format  (below) for example output.",
            "title": "Specifying types"
        },
        {
            "location": "/reference/schema/#supported-data-types",
            "text": "Lightbus maps Python types to JSON types. While Python-specific values can be sent using Lightbus,\nthese values will arrive in their JSON form. For example, if you send a  string  then a  string  will arrive.\nHowever, if you send the  Decimal  value  3.124 , then you will receive the  string  value  3.124  instead.  The following types are reasonably interoperable:     Python type sent  JSON schema interpretation  Type received      str  string  str    int ,  float  number  int ,  float    bool  boolean  bool    list ,  tuple  array  list    None  null  None    dict ,  Mapping , etc  object  dict    Mapping[str, ...]  object , with  pattern properties  set  dict    Tuple[A, B, C]  array  with  maxItems/minItems  and  items  set.  list     The following types will be successfully encoded and sent, but will arrive as their encoded equivalent:     Python type  JSON Schema type  Value arrives as      bytes ,  Decimal ,  complex  string  str    datetime ,  date  str  str  (ISO 8601)    NamedTuple  with annotations  object  with  specific typed properties  dict    object  with annotations  object  with  specific typed properties  dict     Lightbus can also handle the following:     Python type  JSON Schema type      Any  {}  (any value)    Union[...]  oneOf{...}  (see  oneOf )    Enum  Sets  enum  property",
            "title": "Supported data types"
        },
        {
            "location": "/reference/schema/#automatic-validation",
            "text": "By default this validation will be validated in both the\nincoming and outgoing directions. Outgoing refers to\nthe dispatching of events or procedure calls to the bus.\nIncoming refers to the processing of procedure calls or\nhandling of received events.  You can configuring this using the  validate  configuration  option.",
            "title": "Automatic validation"
        },
        {
            "location": "/reference/schema/#validation-configuration",
            "text": "You can configure the validation behaviour in your\nbus'  config.yaml .",
            "title": "Validation configuration"
        },
        {
            "location": "/reference/schema/#validate-bool-true",
            "text": "You can enable/disable validation using a boolean true/false flag:  # In config.yaml  apis: \n     default: \n         validate:  false   For finer grained control you can specify individual flags for incoming/outgoing\nvalidation:  # In config.yaml  apis: \n     default: \n         validate: \n           outgoing:  true \n           incoming:  false",
            "title": "validate (bool) = true"
        },
        {
            "location": "/reference/schema/#strict_validation-bool-false",
            "text": "If  strict_validation  is  true  then calling a procedure for which no schema exists will\nresult in an error:  # In config.yaml  apis: \n     default: \n         strict_validation:  true",
            "title": "strict_validation (bool) = false"
        },
        {
            "location": "/reference/schema/#manual-validation",
            "text": "TODO",
            "title": "Manual validation"
        },
        {
            "location": "/reference/schema/#schema-format",
            "text": "You won't need to worry about the schema format in your day-to-day use\nof Lightbus. However, an understanding of the format will be very\nuseful if you decide to build additional tooling.  The Lightbus schema format is simply a collection of child JSON Schemas.\nBelow is the schema for the example  auth  API shown above:  //   Auto-generated   schema   for   auth   API  { \n   \"auth\" :   { \n\n     //   Events   specify   only   parameters \n     \"events\" :   { \n       \"user_registered\" :   { \n         \"parameters\" :   { \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"Event auth.user_registered parameters\" , \n           \"type\" :   \"object\" , \n             \"username\" :   { \n               \"type\" :   \"string\" \n             }, \n           \"properties\" :   { \n             \"email\" :   { \n               \"type\" :   \"string\" \n             }, \n             \"is_admin\" :   { \n               \"default\" :   false , \n               \"type\" :   \"boolean\" \n             } \n           }, \n           \"required\" :   [ \n             \"username\" , \n             \"email\" \n           ], \n           \"additionalProperties\" :   false \n         } \n       } \n     }, \n\n     //   RPCs   specify   both   parameters   and   response \n     \"rpcs\" :   { \n       \"check_password\" :   { \n         \"parameters\" :   { \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"RPC auth.check_password() parameters\" , \n           \"type\" :   \"object\" , \n           \"properties\" :   { \n             \"username\" :   { \n               \"type\" :   \"string\" \n             }, \n             \"password\" :   { \n               \"type\" :   \"string\" \n             } \n           }, \n           \"required\" :   [ \n             \"username\" , \n             \"password\" \n           ], \n           \"additionalProperties\" :   false \n         }, \n\n         \"response\" :   { \n           \"$schema\" :   \"http://json-schema.org/draft-04/schema#\" , \n           \"title\" :   \"RPC auth.check_password() response\" , \n           \"type\" :   \"boolean\" \n         } \n       } \n     } \n   }  }   The generalised format is as follows:  //   Generalised   Lightbus   schema   format  { \n   \"<api-name>\" :   { \n\n     \"events\" :   { \n       \"<event-name>\" :   { \n         \"parameters\" :    {   /*   json   schema   */   } \n       } \n       //   additional   events \n     }, \n\n     \"rpcs\" :   { \n       \"<rpc-name>\" :   { \n         \"parameters\" :   {   /*   json   schema   */   }, \n         \"response\" :   {   /*   json   schema   */   } \n       } \n       //   additional   procedures \n     } \n\n   } \n   //   additional   APIs  }    Note  Lightbus will likely upgrade to a newer JSON Schema version once the  jsonschema Python library  has the  requisite support .",
            "title": "Schema format"
        },
        {
            "location": "/reference/command-line-use/",
            "text": "TBA",
            "title": "Command line use*"
        },
        {
            "location": "/reference/debugging/",
            "text": "TBA",
            "title": "Debugging*"
        },
        {
            "location": "/reference/plugins/",
            "text": "TBA",
            "title": "Plugins*"
        }
    ]
}