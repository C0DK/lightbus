from typing import Sequence, Tuple, Any

import asyncio_extras

from lightbus.api import Api
from lightbus.message import RpcMessage, EventMessage, ResultMessage
from lightbus.utilities import MessageConsumptionContext


class RpcTransport(object):
    """Implement the sending and receiving of RPC calls"""

    async def call_rpc(self, rpc_message: RpcMessage):
        """Publish a call to a remote procedure"""
        raise NotImplementedError()

    async def consume_rpcs(self, apis: Sequence[Api]) -> Sequence[RpcMessage]:
        """Consume RPC calls for the given API"""
        raise NotImplementedError()


class ResultTransport(object):
    """Implement the send & receiving of results

    """

    def get_return_path(self, rpc_message: RpcMessage) -> str:
        raise NotImplementedError()

    async def send_result(self, rpc_message: RpcMessage, result_message: ResultMessage, return_path: str):
        """Send a result back to the caller

        Args:
            rpc_message (): The original message received from the client
            result_message (): The result message to be sent back to the client
            return_path (str): The string indicating where to send the result.
                As generated by :ref:`get_return_path()`.
        """
        raise NotImplementedError()

    async def receive_result(self, rpc_message: RpcMessage, return_path: str) -> ResultMessage:
        """Receive the result for the given message

        Args:
            rpc_message (): The original message sent to the server
            return_path (str): The string indicated where to receive the result.
                As generated by :ref:`get_return_path()`.
        """
        raise NotImplementedError()


class EventTransport(object):
    """ Implement the sending/consumption of events over a given transport.

    The simplest implementation should simply be capable of:

        1. Consuming all events
        2. Sending events

    However, consuming all events will probably be unnecessary in most situations.
    You can therefore selectively listen for events by implementing
    ``start_listening_for()`` and ``stop_listening_for()``.

    Implementing these methods will have several benefits:

      * Will reduce resource use
      * Will allow for dynamically changing listened-for events at runtime

    See Also:

        lightbus.RedisEventTransport: Implements the start_listening_for()
            and stop_listening_for() methods

    """

    async def send_event(self, event_message: EventMessage):
        """Publish an event"""
        raise NotImplementedError()

    def consume_events(self):
        return MessageConsumptionContext(
            fetch=self.fetch_events,
            on_consumed=self.consumption_complete,
        )

    async def fetch_events(self) -> Tuple[Sequence[EventMessage], Any]:
        """Consume RPC events for the given API

        Must return a tuple, where the first item is a iterable of
        event messages and the second item is an arbitrary value which will
        be passed to consumption_complete() (below) should the events
        be executed successfully.

        Events that the bus is not listening for may be returned, they
        will simply be ignored.

        """
        raise NotImplementedError()

    async def consumption_complete(self, extra):
        pass

    async def start_listening_for(self, api_name, event_name):
        """Instruct this transport to start listening for the given event"""
        pass

    async def stop_listening_for(self, api_name, event_name):
        """Instruct this transport to stop listening for the given event"""
        pass
