import inspect
import logging
from typing import Sequence, Tuple, List, Generator, Dict, NamedTuple, Optional, TypeVar, Type, Callable, Hashable

from lightbus.api import Api
from lightbus.exceptions import NothingToListenFor, TransportNotFound
from lightbus.message import RpcMessage, EventMessage, ResultMessage
from lightbus.utilities.importing import load_entrypoint_classes

T = TypeVar('T')
logger = logging.getLogger(__name__)


def make_transport_config_structure(class_name, from_config_method):
    # TODO: Move onto transport metaclass?
    code = f"class {class_name}Config(NamedTuple):\n    pass\n"
    vars = dict(p={})

    parameters = inspect.signature(from_config_method).parameters.values()
    for parameter in parameters:
        if parameter.kind in (parameter.POSITIONAL_ONLY, parameter.VAR_POSITIONAL):
            logger.warning(
                f'Positional-only arguments are not supported in from_config() on transport {class_name}'
            )
        elif parameter.kind in (parameter.VAR_KEYWORD, ):
            logger.warning(
                f'**kwargs-style parameters are not supported in from_config() on transport {class_name}'
            )
        else:
            name = parameter.name
            vars['p'][name] = parameter
            code += f"    {name}: p['{name}'].annotation = p['{name}'].default\n"

    globals_ = globals().copy()
    globals_.update(vars)
    exec(code, globals_)
    return globals_[f'{class_name}Config']


class TransportMetaclass(type):

    def __new__(mcs, name, bases, attrs, **kwds):
        cls = super().__new__(mcs, name, bases, attrs)
        if not hasattr(cls, f'{name}Config') and hasattr(cls, 'from_config'):
            cls.Config = make_transport_config_structure(name, cls.from_config)
        return cls


class Transport(object, metaclass=TransportMetaclass):

    @classmethod
    def from_config(cls: Type[T]) -> T:
        return cls()


class RpcTransport(Transport):
    """Implement the sending and receiving of RPC calls"""

    async def call_rpc(self, rpc_message: RpcMessage, options: dict):
        """Publish a call to a remote procedure"""
        RpcTransport.from_config()
        raise NotImplementedError()

    async def consume_rpcs(self, apis: Sequence[Api]) -> Sequence[RpcMessage]:
        """Consume RPC calls for the given API"""
        raise NotImplementedError()


class ResultTransport(Transport):
    """Implement the send & receiving of results

    """

    def get_return_path(self, rpc_message: RpcMessage) -> str:
        raise NotImplementedError()

    async def send_result(self, rpc_message: RpcMessage, result_message: ResultMessage, return_path: str):
        """Send a result back to the caller

        Args:
            rpc_message (): The original message received from the client
            result_message (): The result message to be sent back to the client
            return_path (str): The string indicating where to send the result.
                As generated by :ref:`get_return_path()`.
        """
        raise NotImplementedError()

    async def receive_result(self, rpc_message: RpcMessage, return_path: str, options: dict) -> ResultMessage:
        """Receive the result for the given message

        Args:
            rpc_message (): The original message sent to the server
            return_path (str): The string indicated where to receive the result.
                As generated by :ref:`get_return_path()`.
            options (dict): Dictionary of options specific to this particular backend
        """
        raise NotImplementedError()


class EventTransport(Transport):
    """ Implement the sending/consumption of events over a given transport.
    """

    async def send_event(self, event_message: EventMessage, options: dict):
        """Publish an event"""
        raise NotImplementedError()

    def consume(self, listen_for: List[Tuple[str, str]], context: dict, **kwargs):
        """Consume messages for the given APIs

        Examples:

            Consuming events::

                listen_for = [
                    ('mycompany.auth', 'user_created'),
                    ('mycompany.auth', 'user_updated'),
                ]
                async with event_transport.consume(listen_for) as event_message:
                    print(event_message)

        """
        if not listen_for:
            raise NothingToListenFor(
                'EventTransport.consume() was called without providing anything '
                'to listen for in the "listen_for" argument.'
            )
        return self.fetch(listen_for, context, **kwargs)

    async def fetch(self, listen_for: List[Tuple[str, str]], context:dict, **kwargs) -> Generator[EventMessage, None, None]:
        """Consume RPC messages for the given events

        Events the bus is not listening for may be returned, they
        will simply be ignored.
        """
        raise NotImplementedError()

    async def consumption_complete(self, event_message: EventMessage, context: dict):
        pass


class SchemaTransport(Transport):
    """ Implement sharing of lightbus API schemas
    """

    async def store(self, api_name: str, schema: Dict, ttl_seconds: int):
        """Store a schema for the given API"""
        raise NotImplementedError()

    async def ping(self, api_name: str, schema: Dict, ttl_seconds: int):
        """Keep alive a schema already stored via store()

        The defaults to simply calling store() on the assumption that this
        will cause the ttl to be updated. Backends may choose to
        customise this logic.
        """
        await self.store(api_name, schema, ttl_seconds)

    async def load(self) -> Dict[str, Dict]:
        """Load the schema for all APIs

        Should return a mapping of API names to schemas
        """
        raise NotImplementedError()


empty = NamedTuple('Empty')


class TransportRegistry(object):
    """ Manages access to transports

    It is possible for different APIs within lightbus to use different transports.
    This registry handles the logic of loading the transports for a given
    configuration. Thereafter, it provides access to these transports based on
    a given API.

    The 'default' API is a special case as it is fallback transport for
    any APIs that do not have their own specific transports configured.
    """

    class _RegistryEntry(NamedTuple):
        rpc: RpcTransport = None
        result: ResultTransport = None
        event: EventTransport = None
        schema: SchemaTransport = None

    def __init__(self):
        self._registry: Dict[str, self._RegistryEntry] = {}

    def load_config(self, config: 'Config') -> 'TransportRegistry':
        for api_name, api_config in config.apis().items():
            for transport_type in ('event', 'rpc', 'result', 'schema'):
                transport_config = self._get_transport_config(api_config, transport_type)
                if transport_config:
                    transport_name, transport_config = transport_config
                    transport = self._instantiate_transport(transport_type, transport_name, transport_config)
                    self._set_transport(api_name, transport, transport_type)
        return self

    def _get_transport_config(self, api_config: 'ApiConfig', type_: str):
        transport_selector = getattr(api_config, f'{type_}_transport')
        for transport_name in transport_selector._fields:
            transport_config = getattr(transport_selector, transport_name)
            if transport_config is not None:
                return transport_name, transport_config

    def _instantiate_transport(self, type_, name, config):
        transport_class = get_transport(type_=type_, name=name)
        transport = transport_class.from_config(config)
        return transport

    def _set_transport(self, api_name: str, transport: Transport, transport_type: str):
        self._registry.setdefault(api_name, self._RegistryEntry())
        self._registry[api_name] = self._registry[api_name]._replace(**{transport_type: transport})

    def _get_transport(self, api_name: str, transport_type: str, default=empty):
        registry_entry = self._registry.get(api_name)
        api_transport = None
        if registry_entry:
            api_transport = getattr(registry_entry, transport_type)

        if not api_transport and api_name != 'default':
            try:
                api_transport = self._get_transport('default', transport_type)
            except TransportNotFound:
                pass

        if not api_transport and default == empty:
            raise TransportNotFound(
                f"No {transport_type} transport found for API '{api_name}'. Neither was a default "
                f"API transport found. Either specify a {transport_type} transport for this specific API, "
                f"or specify a default {transport_type} transport. In most cases setting a default transport "
                f"is the best course of action."
            )
        else:
            return api_transport

    def _get_transports(self, api_names: Sequence[str], transport_type: str) -> List[Tuple[Transport, List[str]]]:
        apis_by_transport: Dict[Transport, List[str]] = {}
        for api_name in api_names:
            transport = self._get_transport(api_name, transport_type)
            apis_by_transport.setdefault(transport, [])
            apis_by_transport[transport].append(api_name)
        return list(apis_by_transport.items())

    def _has_transport(self, api_name: str, transport_type: str) -> bool:
        try:
            self._get_transport(api_name, transport_type)
        except TransportNotFound:
            return False
        else:
            return True

    def set_rpc_transport(self, api_name: str, transport):
        self._set_transport(api_name, transport, 'rpc')

    def set_result_transport(self, api_name: str, transport):
        self._set_transport(api_name, transport, 'result')

    def set_event_transport(self, api_name: str, transport):
        self._set_transport(api_name, transport, 'event')

    def set_schema_transport(self, api_name: str, transport):
        self._set_transport(api_name, transport, 'schema')

    def get_rpc_transport(self, api_name: str, default=empty) -> RpcTransport:
        return self._get_transport(api_name, 'rpc', default=default)

    def get_result_transport(self, api_name: str, default=empty) -> ResultTransport:
        return self._get_transport(api_name, 'result', default=default)

    def get_event_transport(self, api_name: str, default=empty) -> EventTransport:
        return self._get_transport(api_name, 'event', default=default)

    def get_schema_transport(self, api_name: str, default=empty) -> SchemaTransport:
        # TODO: This is only available globally, not per api. Perhaps it needs to be be under apis in the config
        return self._get_transport(api_name, 'schema', default=default)

    def has_rpc_transport(self, api_name: str) -> bool:
        self._has_transport(api_name, 'rpc')

    def has_result_transport(self, api_name: str) -> bool:
        self._has_transport(api_name, 'result')

    def has_event_transport(self, api_name: str) -> bool:
        self._has_transport(api_name, 'event')

    def has_schema_transport(self, api_name: str) -> bool:
        self._has_transport(api_name, 'schema')

    def get_rpc_transports(self, api_names: Sequence[str]) -> List[Tuple[RpcTransport, List[str]]]:
        """Get a mapping of transports to lists of APIs

        This is useful when multiple APIs can be served by a single transport
        """
        return self._get_transports(api_names, 'rpc')

    def get_event_transports(self, api_names: Sequence[str]) -> List[Tuple[EventTransport, List[str]]]:
        """Get a mapping of transports to lists of APIs

        This is useful when multiple APIs can be served by a single transport
        """
        return self._get_transports(api_names, 'event')


def get_available_transports(type_):
    loaded = load_entrypoint_classes(f'lightbus_{type_}_transports')

    return {
        name: class_
        for module_name, name, class_
        in loaded
    }


def get_transport(type_, name):
    for name_, class_ in get_available_transports(type_).items():
        if name == name_:
            return class_

    raise TransportNotFound(
        f"No '{type_}' transport found named '{name}'. Check the transport is installed and "
        f"has the relevant entrypoints setup in it's setup.py file. Or perhaps "
        f"you have a typo in your config file."
    )


def get_transport_name(cls: Type['Transport']):
    for type_ in ('rpc', 'result', 'event', 'schema'):
        for *_, name, class_ in load_entrypoint_classes(f'lightbus_{type_}_transports'):
            if cls == class_:
                return name

    raise TransportNotFound(
        f"Transport class {cls.__module__}.{cls.__name__} is not specified in any entrypoint."
    )
